<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Titan Premium Analysis - Enterprise-grade ML analytics platform">
  <title>Analytics - Vox Amelior</title>

  <!-- External CSS - High-Tech Theme -->
  <link rel="stylesheet" href="demo/assets/css/predictions-premium.css">
  <link rel="stylesheet" href="demo/assets/css/predictions-premium-2.css">
  <link rel="stylesheet" href="demo/assets/css/predictions-premium-3.css">
  <link rel="stylesheet" href="demo/assets/css/predictions-premium-4.css">
  <link rel="stylesheet" href="demo/assets/css/predictions-visualizations.css">
  <link rel="stylesheet" href="demo/assets/css/predictions/predictions-engines.css">

  <!-- Financial Premium Styles -->
  <link rel="stylesheet" href="demo/assets/css/financial-premium.css">

  <!-- Vox Amelior Design System -->
  <link rel="stylesheet" href="demo/assets/css/vox-amelior.css">

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>

  <!-- Plotly.js for advanced visualizations (3D scatter, heatmaps, waterfall) -->
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

  <!-- Apache ECharts for radar charts and gauges -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>

  <!-- Financial Charts Modules -->
  <script src="demo/assets/js/financial-charts-core.js"></script>
  <script src="demo/assets/js/financial-charts-flow.js"></script>
  <script src="demo/assets/js/financial-charts-kpi.js"></script>
  <script src="demo/assets/js/financial-charts-advanced.js"></script>

  <!-- Google Fonts - Inter -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>

<body>
  <!-- Navigation (Vox Amelior) -->
  <nav class="vox-nav">
    <div class="vox-nav-inner">
      <a href="index.html" class="vox-logo">
        <div class="vox-logo-mark">
          <img src="demo/assets/images/logo.png" alt="Vox Amelior Logo">
        </div>
        <span class="vox-logo-text">Vox Amelior</span>
      </a>

      <div class="vox-nav-links">
        <a href="demo/index.html" class="vox-nav-link">Dashboard</a>
        <a href="demo/gemma.html" class="vox-nav-link">AI Assistant</a>
        <a href="predictions.html" class="vox-nav-link active">Analytics</a>
        <a href="demo/banking.html" class="vox-nav-link">Enterprise</a>
        <a href="demo/settings.html" class="vox-nav-link">Settings</a>
      </div>

      <div style="display: flex; gap: 0.75rem; align-items: center;">
        <span style="font-size: 0.85rem; color: var(--vox-grey-500);">ğŸš€ Premium Analysis</span>
        <div class="header-badge"
          style="background: linear-gradient(135deg, #02559e, #457baf); color: white; padding: 0.25rem 0.75rem; border-radius: 20px; font-size: 0.75rem; font-weight: 600;">
          âœ¨ 27 Engines</div>
        <a href="demo/login.html" class="vox-btn vox-btn-ghost">Sign Out</a>
      </div>
    </div>
  </nav>

  <main>
    <div class="card" id="upload-section">
      <div class="card-title">ğŸ“‚ Upload Your Dataset</div>
      <div class="upload-area" id="upload-area" onclick="document.getElementById('file-input').click()">
        <div class="upload-icon">ğŸ“Š</div>
        <div class="upload-text">Drop your Database file here</div>
        <div class="upload-hint">or click to browse â€¢ Max 50MB</div>
      </div>
      <input type="file" id="file-input"
        accept=".csv,.tsv,.txt,.json,.jsonl,.ndjson,.xlsx,.xls,.parquet,.db,.sqlite,.sqlite3" style="display: none;">
      <div
        style="text-align: center; margin-top: 20px; display: flex; flex-direction: column; gap: 12px; justify-content: center; align-items: center;">
        <div style="display: flex; gap: 12px; align-items: center;">
          <button class="btn btn-lg" id="analyze-btn" disabled>âš¡ Run Premium Analysis</button>
          <button class="btn btn-secondary" id="stop-btn"
            style="display: none; background: linear-gradient(135deg, #f59e0b, #d97706);" onclick="stopAnalysis()">â¹ï¸
            Stop
            Here</button>
          <button class="btn btn-secondary" id="resume-btn"
            style="display: none; background: linear-gradient(135deg, #10b981, #059669);" onclick="resumeAnalysis()">â–¶ï¸
            Resume</button>
          <button class="btn btn-secondary" id="clear-btn"
            style="display: none; background: linear-gradient(135deg, #ef4444, #dc2626);"
            onclick="clearAnalysisPage()">ğŸ—‘ï¸ Clear</button>
        </div>
        <label
          style="display: flex; align-items: center; gap: 8px; color: #e2e8f0; cursor: pointer; background: rgba(255,255,255,0.05); padding: 8px 16px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1);">
          <input type="checkbox" id="use-vectors" style="width: 16px; height: 16px;">
          <span>ğŸ’ Use Gemma Vectorization (Higher Accuracy)</span>
        </label>
      </div>
      <div class="status-bar" id="status-bar"><span>ğŸ‘‹ Upload a dataset to begin</span></div>
      <div class="progress-bar">
        <div class="fill" id="progress-fill"></div>
      </div>
    </div>

    <!-- Column Selection Card (appears after upload) -->
    <div class="card column-selection-card" id="column-selection-section">
      <div class="card-title">ğŸ¯ Column Selection</div>
      <p style="color: #94a3b8; margin-bottom: 16px;">Choose how to select your target column and features for analysis.
      </p>

      <div class="selection-mode-toggle">
        <button class="mode-btn active" id="mode-gemma" onclick="setSelectionMode('gemma')">
          ğŸ¤– Gemma AI (Auto)
        </button>
        <button class="mode-btn" id="mode-manual" onclick="setSelectionMode('manual')">
          âœ‹ Manual Selection
        </button>
      </div>

      <!-- Gemma Mode Info -->
      <div id="gemma-mode-panel">
        <div class="gemma-mode-info">
          <strong>ğŸ¤– Gemma AI Mode:</strong> Gemma will analyze your columns and automatically recommend the best target
          variable and relevant features for prediction.
        </div>
      </div>

      <!-- Manual Mode Panel (hidden by default) -->
      <div id="manual-mode-panel" style="display: none;">
        <div class="column-selector">
          <div class="column-selector-title">ğŸ¯ Target Column (What to Predict)</div>
          <select id="target-select" onchange="onTargetChange()">
            <option value="">-- Select target column --</option>
          </select>
        </div>

        <div class="column-selector">
          <div class="column-selector-title">ğŸ“Š Feature Columns (Input Variables)</div>
          <div class="feature-checkbox-grid" id="feature-grid">
            <!-- Populated by JavaScript -->
          </div>
          <div class="selection-actions">
            <button class="select-all-btn" onclick="selectAllFeatures()">âœ… Select All</button>
            <button class="select-all-btn" onclick="deselectAllFeatures()">âŒ Deselect All</button>
            <span id="feature-count" style="color: #94a3b8; font-size: 0.85rem; margin-left: auto;">0 features
              selected</span>
          </div>
        </div>

        <div class="manual-mode-info">
          <strong>âœ‹ Manual Mode:</strong> You've taken control! Select your target column and check the features you
          want to include in the analysis. Features you don't select will be ignored.
        </div>
      </div>
    </div>

    <div class="results-section" id="results-section">
      <!-- Tab Navigation -->
      <div class="tabs">
        <button class="tab-btn active" onclick="switchTab('overview')">ğŸ“Š Overview</button>
        <button class="tab-btn" onclick="switchTab('models')">ğŸ† Models</button>
        <button class="tab-btn" onclick="switchTab('features')">ğŸ“ˆ Features</button>
        <button class="tab-btn" onclick="switchTab('forecasting')" id="forecasting-tab-btn" style="display: none;">ğŸ”®
          Forecasting</button>
        <button class="tab-btn" onclick="switchTab('methodology')">ğŸ”¬ Methodology</button>
        <button class="tab-btn" onclick="switchTab('config')">âš™ï¸ Config</button>
      </div>

      <!-- Overview Tab -->
      <div class="tab-content active" id="tab-overview">
        <div class="hero-headline" id="hero-section">
          <h2 id="hero-title">Analysis Complete</h2>
          <div class="hero-explanation" id="hero-explanation"></div>
          <div class="hero-confidence" id="hero-confidence"><span id="confidence-text">High Confidence</span></div>
        </div>

        <!-- Test Run Summary -->
        <div class="card" id="test-summary-section">
          <div class="card-title">ğŸ“‹ Test Run Summary</div>
          <div id="test-summary-content" style="line-height: 1.8; color: #cbd5e1;">
            <!-- Populated by JavaScript -->
          </div>
        </div>

        <div class="stats-grid" id="stats-grid">
          <div class="stat-card">
            <div class="stat-value" id="stat-rows">-</div>
            <div class="stat-label">Records</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="stat-cols">-</div>
            <div class="stat-label">Features</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="stat-accuracy">-</div>
            <div class="stat-label">Best Accuracy</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="stat-time">-</div>
            <div class="stat-label">Analysis Time</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="stat-models">-</div>
            <div class="stat-label">Models Tested</div>
          </div>
        </div>

        <!-- Forecast Summary in Overview (shows when forecast is complete) -->
        <div class="forecast-overview-card" id="forecast-overview-card">
          <div class="forecast-overview-header">
            <div class="forecast-overview-title">
              <span>ğŸ”®</span> Time-Series Forecast Results
            </div>
            <div class="forecast-overview-accuracy rating-excellent" id="forecast-overview-rating">
              ğŸŒŸ Excellent Accuracy
            </div>
          </div>
          <div class="forecast-overview-grid">
            <div class="forecast-overview-stat">
              <div class="value" id="forecast-overview-mape">-</div>
              <div class="label">MAPE Accuracy</div>
            </div>
            <div class="forecast-overview-stat">
              <div class="value" id="forecast-overview-trend">-</div>
              <div class="label">Trend Direction</div>
            </div>
            <div class="forecast-overview-stat">
              <div class="value" id="forecast-overview-periods">-</div>
              <div class="label">Forecast Periods</div>
            </div>
            <div class="forecast-overview-stat">
              <div class="value" id="forecast-overview-target">-</div>
              <div class="label">Target Variable</div>
            </div>
          </div>
          <!-- Gemma AI Explanation -->
          <div class="gemma-explanation-card" id="forecast-gemma-explanation">
            <div class="gemma-explanation-header">
              <span class="icon">ğŸ¤–</span>
              <span class="title">Gemma AI Explains Your Forecast</span>
              <span class="status" id="gemma-explain-status">Analyzing...</span>
            </div>
            <div class="gemma-explanation-loading" id="gemma-explain-loading">
              <div class="spinner"></div>
              <span>Gemma is analyzing your forecast results...</span>
            </div>
            <div class="gemma-explanation-text" id="gemma-explain-text" style="display: none;"></div>
          </div>
          <div style="margin-top: 16px; text-align: center;">
            <button class="btn" onclick="switchTab('forecasting')"
              style="background: linear-gradient(135deg, #67e8f9, #f472b6);">
              ğŸ”® View Full Forecast Details
            </button>
          </div>
        </div>

        <!-- Retry with different target (shown when results are poor) -->
        <div class="card" id="retry-section" style="display: none;">
          <div class="card-title">ğŸ”„ Try a Different Target?</div>
          <p style="color: #94a3b8; margin-bottom: 16px; line-height: 1.6;">The results weren't great. This might mean
            the selected target column isn't easily predictable from the available features.</p>
          <div id="excluded-targets" style="margin-bottom: 16px;"></div>
          <button class="btn" onclick="retryWithDifferentTarget()"
            style="background: linear-gradient(135deg, #f59e0b, #d97706);">ğŸ”„ Let Gemma Try Another Target</button>
        </div>
      </div>

      <!-- Models Tab -->
      <div class="tab-content" id="tab-models">
        <div class="card" id="variants-section">
          <div class="card-title">ğŸ† Model Comparison</div>
          <p id="variants-explanation" style="color: #94a3b8; margin-bottom: 16px; line-height: 1.6;">We tested multiple
            machine learning models on your data. The <strong style="color:#10b981;">CV Score (Cross-Validation
              Score)</strong> shows how accurately each model can predict your target column - higher is better.</p>
          <div class="variants-grid" id="variants-container"></div>
          <div style="margin-top: 20px; padding: 16px; background: rgba(255,255,255,0.02); border-radius: 10px;">
            <p id="model-summary" style="color: #94a3b8; font-size: 0.9rem; margin: 0;"></p>
            <div class="chart-wrapper" style="height: 180px; margin-top: 12px;"><canvas id="model-chart"></canvas></div>
          </div>
        </div>
      </div>

      <!-- Features Tab -->
      <div class="tab-content" id="tab-features">
        <div class="card" id="features-section">
          <div class="card-title">ğŸ“Š What Matters Most</div>
          <p id="features-explanation" style="color: #94a3b8; margin-bottom: 16px; line-height: 1.6;"><strong
              style="color:#67e8f9;">Feature Stability</strong> shows how consistently each column in your data helps
            predict the target. Features with higher stability (%) appear important across multiple test runs.</p>
          <div class="feature-list" id="feature-list"></div>
          <div style="margin-top: 20px; padding: 16px; background: rgba(255,255,255,0.02); border-radius: 10px;">
            <p id="feature-summary" style="color: #94a3b8; font-size: 0.9rem; margin: 0 0 12px 0;"></p>
            <div class="chart-wrapper" style="height: 160px;"><canvas id="feature-chart"></canvas></div>
          </div>
        </div>
      </div>

      <!-- Forecasting Tab (Chronos Engine) -->
      <div class="tab-content" id="tab-forecasting">
        <div class="card">
          <div class="card-title">ğŸ”® Time-Series Forecasting</div>
          <p style="color: #94a3b8; margin-bottom: 16px; line-height: 1.6;">
            Powered by <strong style="color: #f472b6;">Chronos Engine</strong> (Facebook Prophet).
            Analyzes historical patterns to predict future values with confidence intervals.
          </p>

          <!-- Column Selection for Forecasting -->
          <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; margin-bottom: 20px;">
            <div>
              <label style="display: block; color: #67e8f9; font-weight: 500; margin-bottom: 8px;">ğŸ“… Time
                Column</label>
              <select id="forecast-time-col" onchange="onForecastConfigChange()"
                style="width: 100%; padding: 10px 14px; background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.12); border-radius: 8px; color: #e2e8f0; font-size: 0.9rem;">
                <option value="">Auto-detect</option>
              </select>
            </div>
            <div>
              <label style="display: block; color: #67e8f9; font-weight: 500; margin-bottom: 8px;">ğŸ¯ Value to
                Forecast</label>
              <select id="forecast-target-col" onchange="onForecastConfigChange()"
                style="width: 100%; padding: 10px 14px; background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.12); border-radius: 8px; color: #e2e8f0; font-size: 0.9rem;">
                <option value="">Auto-detect</option>
              </select>
            </div>
            <div>
              <label style="display: block; color: #67e8f9; font-weight: 500; margin-bottom: 8px;">ğŸ“† Forecast
                Periods</label>
              <div style="display: flex; align-items: center; gap: 12px;">
                <input type="range" id="forecast-periods" min="7" max="90" value="30"
                  onchange="updateForecastPeriodLabel()" style="flex: 1;">
                <span id="forecast-periods-label" style="color: #e2e8f0; font-weight: 600; min-width: 60px;">30
                  days</span>
              </div>
            </div>
          </div>

          <button class="btn" onclick="runChronosForecast()" id="run-forecast-btn" style="margin-bottom: 20px;">
            ğŸ”® Generate Forecast
          </button>

          <!-- Forecast Status -->
          <div id="forecast-status" style="display: none; padding: 12px 16px; border-radius: 8px; margin-bottom: 16px;">
          </div>

          <!-- Forecast Results -->
          <div id="forecast-results" style="display: none;">
            <!-- SVG Gradient Definition (hidden) -->
            <svg width="0" height="0" style="position: absolute;">
              <defs>
                <linearGradient id="accuracyGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                  <stop offset="0%" style="stop-color:#10b981" />
                  <stop offset="100%" style="stop-color:#3b82f6" />
                </linearGradient>
              </defs>
            </svg>

            <!-- Accuracy Hero Section -->
            <div class="forecast-hero visible" id="forecast-accuracy-hero">
              <div class="forecast-hero-header">
                <div class="accuracy-ring">
                  <svg viewBox="0 0 100 100">
                    <circle class="bg" cx="50" cy="50" r="40" />
                    <circle class="progress" id="accuracy-progress" cx="50" cy="50" r="40" />
                  </svg>
                  <div class="center-text">
                    <div class="percent" id="accuracy-percent">-</div>
                    <div class="label">Accuracy</div>
                  </div>
                </div>
                <div class="forecast-hero-content">
                  <div class="forecast-hero-title">
                    <span id="hero-accuracy-title">Forecast Accuracy</span>
                    <span class="rating-badge rating-excellent" id="hero-rating-badge">ğŸŒŸ Excellent</span>
                  </div>
                  <div class="forecast-hero-subtitle" id="hero-accuracy-subtitle">
                    Our model can predict future values with high precision. This means your forecast is reliable for
                    business planning.
                  </div>
                  <div class="forecast-hero-stats">
                    <div class="forecast-mini-stat">
                      <span class="icon">ğŸ“Š</span>
                      <span class="value" id="hero-mae">-</span>
                      <span class="unit">MAE</span>
                    </div>
                    <div class="forecast-mini-stat">
                      <span class="icon">ğŸ“‰</span>
                      <span class="value" id="hero-rmse">-</span>
                      <span class="unit">RMSE</span>
                    </div>
                    <div class="forecast-mini-stat">
                      <span class="icon">ğŸ“…</span>
                      <span class="value" id="hero-periods">-</span>
                      <span class="unit">Periods</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Metrics Row -->
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 20px;">
              <div
                style="background: rgba(16,185,129,0.1); border: 1px solid rgba(16,185,129,0.3); border-radius: 10px; padding: 14px; text-align: center;">
                <div style="font-size: 1.4rem; font-weight: 700; color: #10b981;" id="forecast-mape">-</div>
                <div style="font-size: 0.8rem; color: #94a3b8;">MAPE (Accuracy)</div>
              </div>
              <div
                style="background: rgba(59,130,246,0.1); border: 1px solid rgba(59,130,246,0.3); border-radius: 10px; padding: 14px; text-align: center;">
                <div style="font-size: 1.4rem; font-weight: 700; color: #60a5fa;" id="forecast-trend">-</div>
                <div style="font-size: 0.8rem; color: #94a3b8;">Trend Direction</div>
              </div>
              <div
                style="background: rgba(6,182,212,0.1); border: 1px solid rgba(6,182,212,0.3); border-radius: 10px; padding: 14px; text-align: center;">
                <div style="font-size: 1.4rem; font-weight: 700; color: #67e8f9;" id="forecast-next">-</div>
                <div style="font-size: 0.8rem; color: #94a3b8;">Next Period</div>
              </div>
              <div
                style="background: rgba(236,72,153,0.1); border: 1px solid rgba(236,72,153,0.3); border-radius: 10px; padding: 14px; text-align: center;">
                <div style="font-size: 1.4rem; font-weight: 700; color: #f472b6;" id="forecast-final">-</div>
                <div style="font-size: 0.8rem; color: #94a3b8;">Final Period</div>
              </div>
            </div>

            <!-- Legend -->
            <div style="display: flex; gap: 20px; margin-bottom: 16px; flex-wrap: wrap;">
              <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 24px; height: 3px; background: #60a5fa;"></div>
                <span style="color: #94a3b8; font-size: 0.85rem;">Historical Data</span>
              </div>
              <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 24px; height: 3px; background: #10b981; border-style: dashed;"></div>
                <span style="color: #94a3b8; font-size: 0.85rem;">Predicted Trend</span>
              </div>
              <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 24px; height: 12px; background: rgba(6,182,212,0.3); border-radius: 2px;"></div>
                <span style="color: #94a3b8; font-size: 0.85rem;">Confidence Interval (Â±)</span>
              </div>
            </div>

            <!-- Chart -->
            <div class="chart-wrapper" style="height: 380px; margin-bottom: 16px;">
              <canvas id="forecast-chart"></canvas>
            </div>

            <!-- Explanation -->
            <p id="forecast-explanation"
              style="color: #64748b; font-size: 0.9rem; font-style: italic; line-height: 1.6;"></p>

            <!-- Insights from Backend -->
            <div id="forecast-insights"
              style="margin-top: 16px; padding: 12px; background: rgba(6,182,212,0.05); border-radius: 8px; display: none;">
            </div>

            <!-- All Model Variants Comparison -->
            <div id="forecast-variants" style="margin-top: 24px; display: none;">
              <h3
                style="color: #f8fafc; font-size: 1.2rem; margin-bottom: 16px; display: flex; align-items: center; gap: 8px;">
                <span>ğŸ†</span>
                <span>All Prophet Variants Compared</span>
                <span style="font-size: 0.75rem; color: #94a3b8; font-weight: normal;" id="variant-count-label"></span>
              </h3>
              <div id="variants-comparison-grid" class="variants-grid"></div>
            </div>
          </div>

          <!-- No Time Data Message -->
          <div id="no-time-data" style="display: none; text-align: center; padding: 40px; color: #94a3b8;">
            <div style="font-size: 3rem; margin-bottom: 16px;">ğŸ“…</div>
            <p style="font-size: 1.1rem; margin-bottom: 8px;">No time column detected in your data.</p>
            <p style="font-size: 0.9rem;">Time-series forecasting requires a date/time column (e.g., "date",
              "timestamp", "time").</p>
          </div>
        </div>
      </div>
      <div class="tab-content" id="tab-methodology">
        <div class="card" id="methodology-section">
          <div class="card-title">ğŸ”¬ How We Analyzed Your Data</div>
          <div class="methodology" id="methodology-container"></div>
        </div>

        <div class="card" id="warnings-section" style="display: none;">
          <div class="card-title">âš ï¸ Things to Consider</div>
          <div id="warnings-container"></div>
        </div>

        <div class="card" id="holdout-section" style="display: none;">
          <div class="card-title">âœ… Holdout Validation Results</div>
          <div class="holdout-card" id="holdout-container"></div>
        </div>
      </div>

      <!-- Configuration Tab -->
      <div class="tab-content" id="tab-config">
        <div class="card" id="config-section">
          <div class="card-title">âš™ï¸ Configuration Options</div>
          <p style="color: #94a3b8; margin-bottom: 16px;">Tune these for different results:</p>
          <div class="config-grid" id="config-container"></div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-title">ğŸ“‹ Activity Log</div>
      <div class="log" id="log"></div>
    </div>

    <!-- All Engines Comprehensive Results Section -->
    <div class="card" id="all-engines-section" style="display: none;">
      <div class="card-title">ğŸ§ª All 22 Engines - Comprehensive Analysis Results</div>
      <div id="all-engines-summary"
        style="margin-bottom: 20px; padding: 16px; background: rgba(6,182,212,0.1); border-radius: 8px;">
        <p style="color: #e5e7eb; margin: 0;">
          <strong>Sequential Execution:</strong> Each engine runs one at a time showing full results + Gemma summary.
        </p>
        <p style="color: #94a3b8; margin: 8px 0 0 0; font-size: 0.9rem;">
          Database: <span id="engines-database-name">-</span> |
          Progress: <span id="engines-progress">0/22</span> |
          Status: <span id="engines-status">Ready</span> |
          Time: <span id="engines-total-time">0.0s</span>
        </p>
      </div>

      <!-- Multi-Run Actions Bar -->
      <div class="analysis-actions-bar" id="multi-run-actions" style="display: none;">
        <button class="test-again-btn" id="test-again-btn" onclick="testAgain()">
          ğŸ”„ Test Again <span class="remaining-count" id="remaining-columns-count"></span>
        </button>
        <button class="compare-runs-btn" id="compare-runs-btn" onclick="compareAllRuns()" disabled>
          ğŸ“Š Compare All Runs
        </button>
        <div class="spacer"></div>
        <div class="runs-summary" id="runs-summary">
          <strong>Total Runs:</strong> <span id="total-runs-count">0</span>
        </div>
      </div>



      <!-- ========== VARIANT COMPARISON SECTION ========== -->
      <div class="variant-comparison-section" id="variant-comparison" style="display: none;">
        <h3 class="variant-comparison-title">ğŸ”¬ Engine Variant Comparison</h3>
        <p style="color: #94a3b8; margin-bottom: 16px;">
          Some engines support multiple configurations. Results are compared below.
        </p>

        <div class="metric-cards" id="variant-metrics">
          <div class="metric-card success">
            <div class="metric-value" id="variant-total">0</div>
            <div class="metric-label">Total Variants</div>
          </div>
          <div class="metric-card info">
            <div class="metric-value" id="variant-engines">0</div>
            <div class="metric-label">Engines w/ Variants</div>
          </div>
          <div class="metric-card">
            <div class="metric-value" id="variant-best-time">-</div>
            <div class="metric-label">Best Time</div>
          </div>
          <div class="metric-card warning">
            <div class="metric-value" id="variant-avg-time">-</div>
            <div class="metric-label">Avg Time</div>
          </div>
        </div>

        <table class="variant-table" id="variant-table">
          <thead>
            <tr>
              <th>Engine</th>
              <th>Variant</th>
              <th>Duration</th>
              <th>Status</th>
              <th>Data Size</th>
            </tr>
          </thead>
          <tbody id="variant-table-body">
          </tbody>
        </table>
      </div>
      <!-- ========== END VARIANT COMPARISON ========== -->

      <!-- Engine Category Tabs -->
      <div class="engine-category-tabs">
        <button class="engine-category-btn active" onclick="switchEngineCategory('all')">
          ğŸ“Š All Engines <span class="count">22</span>
        </button>
        <button class="engine-category-btn" onclick="switchEngineCategory('ml')">
          ğŸ¤– ML & Analytics <span class="count">7</span>
        </button>
        <button class="engine-category-btn" onclick="switchEngineCategory('financial')">
          ğŸ’° Financial <span class="count">8</span>
        </button>
        <button class="engine-category-btn" onclick="switchEngineCategory('operations')">
          ğŸ“¦ Operations <span class="count">4</span>
        </button>
        <button class="engine-category-btn" onclick="switchEngineCategory('advanced')">
          ğŸ”¬ Advanced <span class="count">3</span>
        </button>
      </div>

      <!-- Category: All Engines -->
      <div class="engine-category-content active" id="category-all">
        <div class="engine-category-header">
          <h4>ğŸ“Š All Engines</h4>
          <div class="engine-category-stats">
            <span class="stat success" id="all-success-count">âœ“ 0</span>
            <span class="stat error" id="all-error-count">âœ— 0</span>
            <span class="stat pending" id="all-pending-count">â³ 22</span>
          </div>
        </div>
        <div id="all-engines-results"></div>
      </div>

      <!-- Category: ML & Analytics -->
      <div class="engine-category-content" id="category-ml">
        <div class="engine-category-header">
          <h4>ğŸ¤– ML & Analytics Engines</h4>
          <div class="engine-category-stats">
            <span class="stat success" id="ml-success-count">âœ“ 0</span>
            <span class="stat error" id="ml-error-count">âœ— 0</span>
            <span class="stat pending" id="ml-pending-count">â³ 7</span>
          </div>
        </div>
        <div id="ml-engines-results"></div>
      </div>

      <!-- Category: Financial -->
      <div class="engine-category-content" id="category-financial">
        <div class="engine-category-header">
          <h4>ğŸ’° Financial Engines</h4>
          <div class="engine-category-stats">
            <span class="stat success" id="financial-success-count">âœ“ 0</span>
            <span class="stat error" id="financial-error-count">âœ— 0</span>
            <span class="stat pending" id="financial-pending-count">â³ 8</span>
          </div>
        </div>
        <div id="financial-engines-results"></div>
      </div>

      <!-- Category: Operations -->
      <div class="engine-category-content" id="category-operations">
        <div class="engine-category-header">
          <h4>ğŸ“¦ Operations Engines</h4>
          <div class="engine-category-stats">
            <span class="stat success" id="operations-success-count">âœ“ 0</span>
            <span class="stat error" id="operations-error-count">âœ— 0</span>
            <span class="stat pending" id="operations-pending-count">â³ 4</span>
          </div>
        </div>
        <div id="operations-engines-results"></div>
      </div>

      <!-- Category: Advanced -->
      <div class="engine-category-content" id="category-advanced">
        <div class="engine-category-header">
          <h4>ğŸ”¬ Advanced Engines</h4>
          <div class="engine-category-stats">
            <span class="stat success" id="advanced-success-count">âœ“ 0</span>
            <span class="stat error" id="advanced-error-count">âœ— 0</span>
            <span class="stat pending" id="advanced-pending-count">â³ 3</span>
          </div>
        </div>
        <div id="advanced-engines-results"></div>
      </div>
    </div>
  </main>

  <script>
    const API_BASE = window.location.origin;
    let uploadedFilename = null;
    let uploadedColumns = [];  // Store columns from upload
    let analysisResults = null;
    let charts = {};
    let gemmaSelection = null;  // Store Gemma's column selection
    let selectionMode = 'gemma';  // 'gemma' or 'manual'
    let manualTarget = null;  // Manual target selection
    let manualFeatures = [];  // Manual feature selections
    let excludedTargets = [];  // Targets that yielded poor results (for retry)

    // Forecasting (Chronos) state
    let forecastResults = null;
    let detectedTimeColumn = null;
    let detectedTargetColumn = null;
    let hasTimeColumn = false;

    // Gemma explanation state - prevents mixing responses
    let gemmaExplanationPending = false;
    let lastGemmaExplanation = null;

    // ========== ANALYSIS SESSION STATE ==========
    let analysisSession = {
      id: null,
      filename: null,
      startedAt: null,
      stoppedAt: null,
      status: 'idle', // 'idle', 'running', 'paused', 'completed'
      completedEngines: [],
      pendingEngines: [],
      results: {},
      chats: {},  // engineName -> [{role, message, timestamp}]
      currentEngineIndex: 0
    };
    let analysisStopped = false;  // Flag to stop mid-run

    // ========== VISUALIZATION STATE ==========
    let enginePerformanceData = [];  // Track timing & results per engine
    let echartsInstances = {};       // Store ECharts instances
    let plotlyCharts = {};           // Store Plotly chart references
    let dashboardInitialized = false;

    // Color palette for visualizations (matches CSS theme)
    const VIZ_COLORS = {
      primary: '#06b6d4',
      primaryLight: '#22d3ee',
      primaryDark: '#0891b2',
      accent: '#10b981',
      accentLight: '#34d399',
      success: '#10b981',
      warning: '#f59e0b',
      error: '#ef4444',
      info: '#3b82f6',
      background: '#0a0f1c',
      surface: '#111827',
      text: '#e5e7eb',
      textMuted: '#6b7280',
      // Category colors
      ml: '#06b6d4',
      financial: '#f59e0b',
      operations: '#8b5cf6',
      advanced: '#ec4899'
    };

    // ========== CSRF TOKEN HELPER ==========
    function getCsrfToken() {
      const cookies = document.cookie.split(';');
      for (let cookie of cookies) {
        const [name, value] = cookie.trim().split('=');
        if (name === 'ws_csrf') {
          return value;
        }
      }
      return null;
    }

    // ========== MARKDOWN RENDERER FOR GEMMA OUTPUT ==========
    function renderMarkdown(text) {
      // Escape HTML first
      let html = text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');

      // Headers (## and ###)
      html = html.replace(/^### (.+)$/gm, '<h4 style="margin: 0.8em 0 0.4em; color: #67e8f9; font-size: 0.95em;">$1</h4>');
      html = html.replace(/^## (.+)$/gm, '<h3 style="margin: 1em 0 0.5em; color: #06b6d4; font-size: 1.05em;">$1</h3>');

      // Bold (**text** or __text__)
      html = html.replace(/\*\*([^*]+)\*\*/g, '<strong style="color: #e0f2fe;">$1</strong>');
      html = html.replace(/__([^_]+)__/g, '<strong style="color: #e0f2fe;">$1</strong>');

      // Italic (*text* or _text_)
      html = html.replace(/\*([^*]+)\*/g, '<em>$1</em>');
      html = html.replace(/_([^_]+)_/g, '<em>$1</em>');

      // Bullet points (* or -)
      html = html.replace(/^\s*[\*\-]\s+(.+)$/gm, '<li style="margin: 0.3em 0; padding-left: 0.5em;">$1</li>');

      // Wrap consecutive <li> in <ul>
      html = html.replace(/(<li[^>]*>.*?<\/li>\s*)+/g, (match) => {
        return `<ul style="margin: 0.5em 0; padding-left: 1.2em; list-style-type: disc;">${match}</ul>`;
      });

      // Numbers (1. 2. etc)
      html = html.replace(/^\s*(\d+)\.\s+(.+)$/gm, '<li style="margin: 0.3em 0;">$2</li>');

      // Code inline (`code`)
      html = html.replace(/`([^`]+)`/g, '<code style="background: rgba(6, 182, 212, 0.2); padding: 0.1em 0.4em; border-radius: 4px; font-size: 0.9em;">$1</code>');

      // Line breaks (double newline = paragraph, single = br)
      html = html.replace(/\n\n+/g, '</p><p style="margin: 0.8em 0;">');
      html = html.replace(/\n/g, '<br>');

      // Wrap in paragraph
      html = `<div style="line-height: 1.6;">${html}</div>`;

      return html;
    }

    // ========== DASHBOARD VISUALIZATION FUNCTIONS ==========

    // Initialize all dashboard charts
    function initDashboard() {
      if (dashboardInitialized) return;
      dashboardInitialized = true;

      // Initialize ECharts gauges
      initTimingGauges();
      initCategoryRadar();
      initSuccessDonut();

      // Initialize Plotly charts
      initTimelineChart();
      initSpeedRankingChart();
      initDataHeatmap();
    }

    // Initialize timing gauge charts with ECharts
    function initTimingGauges() {
      const gaugeConfigs = [
        { id: 'echarts-total-time', max: 120, color: VIZ_COLORS.primary },
        { id: 'echarts-avg-time', max: 10, color: VIZ_COLORS.accent },
        { id: 'echarts-fastest', max: 5, color: VIZ_COLORS.success },
        { id: 'echarts-slowest', max: 30, color: VIZ_COLORS.warning }
      ];

      gaugeConfigs.forEach(config => {
        const container = document.getElementById(config.id);
        if (!container) return;

        const chart = echarts.init(container, null, { renderer: 'canvas' });
        echartsInstances[config.id] = chart;

        const option = {
          series: [{
            type: 'gauge',
            startAngle: 200,
            endAngle: -20,
            min: 0,
            max: config.max,
            splitNumber: 4,
            itemStyle: {
              color: config.color,
              shadowColor: config.color,
              shadowBlur: 10
            },
            progress: {
              show: true,
              roundCap: true,
              width: 12
            },
            pointer: { show: false },
            axisLine: {
              roundCap: true,
              lineStyle: {
                width: 12,
                color: [[1, 'rgba(255,255,255,0.1)']]
              }
            },
            axisTick: { show: false },
            splitLine: { show: false },
            axisLabel: { show: false },
            title: { show: false },
            detail: {
              valueAnimation: true,
              fontSize: 24,
              fontWeight: 'bold',
              color: config.color,
              offsetCenter: [0, 0],
              formatter: val => val.toFixed(1) + 's'
            },
            data: [{ value: 0 }]
          }]
        };
        chart.setOption(option);
      });
    }

    // Update timing gauges with current data
    function updateTimingGauges(totalTime, avgTime, fastest, slowest) {
      const updates = [
        { id: 'echarts-total-time', value: totalTime },
        { id: 'echarts-avg-time', value: avgTime },
        { id: 'echarts-fastest', value: fastest },
        { id: 'echarts-slowest', value: slowest }
      ];

      updates.forEach(u => {
        const chart = echartsInstances[u.id];
        if (chart) {
          chart.setOption({
            series: [{ data: [{ value: u.value }] }]
          });
        }
      });
    }

    // Initialize category performance radar chart
    function initCategoryRadar() {
      const container = document.getElementById('echarts-category-radar');
      if (!container) return;

      const chart = echarts.init(container, null, { renderer: 'canvas' });
      echartsInstances['category-radar'] = chart;

      const option = {
        backgroundColor: 'transparent',
        radar: {
          indicator: [
            { name: 'ML & Analytics', max: 100 },
            { name: 'Financial', max: 100 },
            { name: 'Operations', max: 100 },
            { name: 'Advanced', max: 100 },
            { name: 'Speed', max: 100 }
          ],
          shape: 'polygon',
          splitNumber: 4,
          axisName: {
            color: VIZ_COLORS.textMuted,
            fontSize: 11
          },
          splitLine: {
            lineStyle: { color: 'rgba(255,255,255,0.1)' }
          },
          splitArea: {
            areaStyle: { color: ['rgba(6,182,212,0.02)', 'rgba(6,182,212,0.05)'] }
          },
          axisLine: {
            lineStyle: { color: 'rgba(255,255,255,0.1)' }
          }
        },
        series: [{
          type: 'radar',
          symbol: 'circle',
          symbolSize: 8,
          lineStyle: {
            width: 2,
            color: VIZ_COLORS.primary
          },
          areaStyle: {
            color: 'rgba(6, 182, 212, 0.2)'
          },
          itemStyle: {
            color: VIZ_COLORS.primary,
            borderColor: VIZ_COLORS.primaryLight,
            borderWidth: 2
          },
          data: [{
            value: [0, 0, 0, 0, 0],
            name: 'Performance'
          }]
        }]
      };
      chart.setOption(option);
    }

    // Update radar chart with category performance
    function updateCategoryRadar(mlScore, financialScore, opsScore, advancedScore, speedScore) {
      const chart = echartsInstances['category-radar'];
      if (chart) {
        chart.setOption({
          series: [{
            data: [{
              value: [mlScore, financialScore, opsScore, advancedScore, speedScore]
            }]
          }]
        });
      }
    }

    // Initialize success rate donut chart
    function initSuccessDonut() {
      const container = document.getElementById('echarts-success-rate');
      if (!container) return;

      const chart = echarts.init(container, null, { renderer: 'canvas' });
      echartsInstances['success-donut'] = chart;

      const option = {
        backgroundColor: 'transparent',
        series: [{
          type: 'pie',
          radius: ['50%', '75%'],
          center: ['50%', '50%'],
          avoidLabelOverlap: false,
          itemStyle: {
            borderRadius: 6,
            borderColor: VIZ_COLORS.background,
            borderWidth: 2
          },
          label: {
            show: true,
            position: 'center',
            formatter: '{d}%',
            fontSize: 28,
            fontWeight: 'bold',
            color: VIZ_COLORS.success
          },
          emphasis: {
            label: {
              show: true,
              fontSize: 32,
              fontWeight: 'bold'
            }
          },
          data: [
            { value: 0, name: 'Success', itemStyle: { color: VIZ_COLORS.success } },
            { value: 0, name: 'Failed', itemStyle: { color: VIZ_COLORS.error } },
            { value: 22, name: 'Pending', itemStyle: { color: 'rgba(255,255,255,0.1)' } }
          ]
        }]
      };
      chart.setOption(option);
    }

    // Update success donut chart
    function updateSuccessDonut(success, failed, pending) {
      const chart = echartsInstances['success-donut'];
      if (chart) {
        const total = success + failed + pending;
        const successPercent = total > 0 ? Math.round((success / total) * 100) : 0;

        chart.setOption({
          series: [{
            label: {
              formatter: successPercent + '%',
              color: success > failed ? VIZ_COLORS.success : VIZ_COLORS.error
            },
            data: [
              { value: success, name: 'Success' },
              { value: failed, name: 'Failed' },
              { value: pending, name: 'Pending' }
            ]
          }]
        });
      }
    }

    // Initialize execution timeline (Plotly Gantt-style)
    function initTimelineChart() {
      const container = document.getElementById('plotly-timeline');
      if (!container) return;

      const layout = {
        paper_bgcolor: 'transparent',
        plot_bgcolor: 'transparent',
        font: { color: VIZ_COLORS.textMuted, size: 11 },
        margin: { l: 120, r: 20, t: 20, b: 40 },
        xaxis: {
          title: 'Time (seconds)',
          gridcolor: 'rgba(255,255,255,0.05)',
          zerolinecolor: 'rgba(255,255,255,0.1)'
        },
        yaxis: {
          autorange: 'reversed',
          gridcolor: 'rgba(255,255,255,0.05)'
        },
        showlegend: false
      };

      Plotly.newPlot(container, [], layout, { responsive: true, displayModeBar: false });
      plotlyCharts['timeline'] = container;
    }

    // Update execution timeline
    function updateTimelineChart(engineData) {
      const container = plotlyCharts['timeline'];
      if (!container || !engineData.length) return;

      // Build bar data for timeline
      const data = [{
        type: 'bar',
        orientation: 'h',
        x: engineData.map(e => e.duration / 1000),
        y: engineData.map(e => e.display),
        marker: {
          color: engineData.map(e => {
            if (e.status === 'error') return VIZ_COLORS.error;
            return VIZ_COLORS[e.category] || VIZ_COLORS.primary;
          }),
          line: { width: 0 }
        },
        text: engineData.map(e => (e.duration / 1000).toFixed(2) + 's'),
        textposition: 'outside',
        textfont: { color: VIZ_COLORS.text, size: 10 },
        hovertemplate: '<b>%{y}</b><br>Duration: %{x:.2f}s<extra></extra>'
      }];

      Plotly.react(container, data, {
        paper_bgcolor: 'transparent',
        plot_bgcolor: 'transparent',
        font: { color: VIZ_COLORS.textMuted, size: 10 },
        margin: { l: 140, r: 50, t: 10, b: 30 },
        xaxis: {
          title: 'Duration (seconds)',
          gridcolor: 'rgba(255,255,255,0.05)',
          zerolinecolor: 'rgba(255,255,255,0.1)'
        },
        yaxis: {
          autorange: 'reversed',
          gridcolor: 'rgba(255,255,255,0.05)'
        },
        showlegend: false
      }, { responsive: true, displayModeBar: false });
    }

    // Initialize speed ranking chart
    function initSpeedRankingChart() {
      const container = document.getElementById('plotly-speed-ranking');
      if (!container) return;

      Plotly.newPlot(container, [], {
        paper_bgcolor: 'transparent',
        plot_bgcolor: 'transparent',
        font: { color: VIZ_COLORS.textMuted },
        margin: { l: 150, r: 30, t: 20, b: 40 }
      }, { responsive: true, displayModeBar: false });

      plotlyCharts['speed-ranking'] = container;
    }

    // Update speed ranking (sorted by fastest)
    function updateSpeedRanking(engineData) {
      const container = plotlyCharts['speed-ranking'];
      if (!container) return;

      const sorted = [...engineData]
        .filter(e => e.status !== 'pending')
        .sort((a, b) => a.duration - b.duration);

      const data = [{
        type: 'bar',
        orientation: 'h',
        x: sorted.map(e => e.duration / 1000),
        y: sorted.map(e => e.display),
        marker: {
          color: sorted.map((e, i) => {
            if (e.status === 'error') return VIZ_COLORS.error;
            // Gradient from green (fast) to orange (slow)
            const ratio = i / sorted.length;
            return i < 3 ? VIZ_COLORS.success :
              i < sorted.length * 0.5 ? VIZ_COLORS.primary :
                VIZ_COLORS.warning;
          }),
          line: { width: 0 }
        },
        text: sorted.map((e, i) => i < 3 ? 'ğŸ†' : ''),
        textposition: 'outside',
        hovertemplate: '<b>%{y}</b><br>%{x:.2f}s<extra></extra>'
      }];

      Plotly.react(container, data, {
        paper_bgcolor: 'transparent',
        plot_bgcolor: 'transparent',
        font: { color: VIZ_COLORS.textMuted, size: 10 },
        margin: { l: 150, r: 40, t: 10, b: 30 },
        xaxis: {
          title: 'Duration (seconds)',
          gridcolor: 'rgba(255,255,255,0.05)'
        },
        yaxis: {
          autorange: 'reversed',
          gridcolor: 'rgba(255,255,255,0.05)'
        }
      }, { responsive: true, displayModeBar: false });
    }

    // Initialize data coverage heatmap
    function initDataHeatmap() {
      const container = document.getElementById('plotly-data-heatmap');
      if (!container) return;

      Plotly.newPlot(container, [], {
        paper_bgcolor: 'transparent',
        plot_bgcolor: 'transparent',
        font: { color: VIZ_COLORS.textMuted }
      }, { responsive: true, displayModeBar: false });

      plotlyCharts['data-heatmap'] = container;
    }

    // Update data coverage heatmap
    function updateDataHeatmap(engineData) {
      const container = plotlyCharts['data-heatmap'];
      if (!container) return;

      // Create heatmap showing data output size by engine and category
      const categories = ['ml', 'financial', 'operations', 'advanced'];
      const categoryNames = ['ML & Analytics', 'Financial', 'Operations', 'Advanced'];

      const zData = categories.map(cat => {
        const catEngines = engineData.filter(e => e.category === cat);
        return catEngines.map(e => e.dataSize ? Math.log10(e.dataSize + 1) : 0);
      });

      const xLabels = engineData.filter(e => e.category === 'ml').map(e => e.display.substring(0, 12));

      const data = [{
        type: 'heatmap',
        z: zData,
        x: xLabels,
        y: categoryNames,
        colorscale: [
          [0, 'rgba(6,182,212,0.1)'],
          [0.5, 'rgba(6,182,212,0.5)'],
          [1, 'rgba(16,185,129,0.9)']
        ],
        showscale: false,
        hovertemplate: '<b>%{y}</b><br>%{x}<br>Data: %{z:.0f} (log)<extra></extra>'
      }];

      Plotly.react(container, data, {
        paper_bgcolor: 'transparent',
        plot_bgcolor: 'transparent',
        font: { color: VIZ_COLORS.textMuted, size: 10 },
        margin: { l: 100, r: 20, t: 10, b: 60 },
        xaxis: { tickangle: -45 },
        yaxis: {}
      }, { responsive: true, displayModeBar: false });
    }

    // Master function to update all dashboard visualizations
    function updateDashboard() {
      if (!enginePerformanceData.length) return;

      // Calculate stats
      const completed = enginePerformanceData.filter(e => e.status !== 'pending');
      const successful = completed.filter(e => e.status === 'success');
      const failed = completed.filter(e => e.status === 'error');
      const pending = enginePerformanceData.filter(e => e.status === 'pending');

      const durations = completed.map(e => e.duration / 1000);
      const totalTime = durations.reduce((a, b) => a + b, 0);
      const avgTime = durations.length ? totalTime / durations.length : 0;
      const fastest = durations.length ? Math.min(...durations) : 0;
      const slowest = durations.length ? Math.max(...durations) : 0;

      // Update gauges
      updateTimingGauges(totalTime, avgTime, fastest, slowest);

      // Update success donut
      updateSuccessDonut(successful.length, failed.length, pending.length);

      // Calculate category scores for radar
      const categoryScores = {};
      ['ml', 'financial', 'operations', 'advanced'].forEach(cat => {
        const catEngines = successful.filter(e => e.category === cat);
        const catTotal = enginePerformanceData.filter(e => e.category === cat).length;
        categoryScores[cat] = catTotal > 0 ? (catEngines.length / catTotal) * 100 : 0;
      });

      // Speed score (inverse of avg time, normalized)
      const speedScore = avgTime > 0 ? Math.max(0, 100 - (avgTime * 10)) : 100;

      updateCategoryRadar(
        categoryScores.ml,
        categoryScores.financial,
        categoryScores.operations,
        categoryScores.advanced,
        speedScore
      );

      // Update timeline and ranking
      updateTimelineChart(completed);
      updateSpeedRanking(completed);

      // Update heatmap
      updateDataHeatmap(enginePerformanceData);
    }

    // Track engine performance when engine completes
    function trackEnginePerformance(engine, duration, status, dataSize) {
      const existing = enginePerformanceData.findIndex(e => e.name === engine.name);
      const perfData = {
        name: engine.name,
        display: engine.display,
        icon: engine.icon,
        category: engine.category,
        duration: duration,
        status: status,
        dataSize: dataSize || 0,
        timestamp: Date.now()
      };

      if (existing >= 0) {
        enginePerformanceData[existing] = perfData;
      } else {
        enginePerformanceData.push(perfData);
      }

      // Update dashboard
      updateDashboard();
    }

    // Reset performance tracking for new analysis
    function resetPerformanceTracking() {
      enginePerformanceData = [];
      variantResults = [];
      dashboardInitialized = false;
    }

    // ========== VARIANT TRACKING ==========
    let variantResults = [];

    // Track variant results
    function trackVariantResult(engineName, variantName, duration, status, dataSize) {
      variantResults.push({
        engine: engineName,
        variant: variantName,
        duration: duration,
        status: status,
        dataSize: dataSize,
        timestamp: Date.now()
      });
      updateVariantDisplay();
    }

    // Update variant comparison display
    function updateVariantDisplay() {
      if (variantResults.length === 0) return;

      // Show section
      document.getElementById('variant-comparison').style.display = 'block';

      // Update metrics
      document.getElementById('variant-total').textContent = variantResults.length;
      const uniqueEngines = new Set(variantResults.map(v => v.engine)).size;
      document.getElementById('variant-engines').textContent = uniqueEngines;

      const durations = variantResults.filter(v => v.status === 'success').map(v => v.duration / 1000);
      if (durations.length > 0) {
        document.getElementById('variant-best-time').textContent = Math.min(...durations).toFixed(2) + 's';
        document.getElementById('variant-avg-time').textContent = (durations.reduce((a, b) => a + b, 0) / durations.length).toFixed(2) + 's';
      }

      // Update table
      const tbody = document.getElementById('variant-table-body');
      tbody.innerHTML = variantResults.map(v => {
        const durationSec = (v.duration / 1000).toFixed(2);
        const speedClass = durationSec < 2 ? 'fast' : durationSec < 10 ? 'medium' : 'slow';
        const statusBadge = v.status === 'success'
          ? '<span class="variant-badge fast">âœ“ Success</span>'
          : '<span class="variant-badge slow">âœ— Failed</span>';

        return `
          <tr>
            <td>${v.engine}</td>
            <td>${v.variant}</td>
            <td><span class="variant-badge ${speedClass}">${durationSec}s</span></td>
            <td>${statusBadge}</td>
            <td>${v.dataSize ? (v.dataSize / 1024).toFixed(1) + ' KB' : '-'}</td>
          </tr>
        `;
      }).join('');
    }

    const el = {
      uploadArea: document.getElementById('upload-area'),
      fileInput: document.getElementById('file-input'),
      analyzeBtn: document.getElementById('analyze-btn'),
      statusBar: document.getElementById('status-bar'),
      progressFill: document.getElementById('progress-fill'),
      resultsSection: document.getElementById('results-section'),
      log: document.getElementById('log')
    };

    // ========== Tab Switching ==========
    function switchTab(tabName) {
      // Hide all tab contents
      document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
      // Deactivate all tab buttons
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      // Show selected tab
      const tabContent = document.getElementById('tab-' + tabName);
      if (tabContent) tabContent.classList.add('active');
      // Activate clicked button
      document.querySelectorAll('.tab-btn').forEach(btn => {
        if (btn.textContent.toLowerCase().includes(tabName.toLowerCase().slice(0, 4))) {
          btn.classList.add('active');
        }
      });
      // Re-render charts if on tabs with charts (they need to be visible to render properly)
      if ((tabName === 'features' || tabName === 'models' || tabName === 'predictions') && analysisResults) {
        setTimeout(renderCharts, 100);
      }
      // Re-render forecast chart when switching to forecasting tab
      if (tabName === 'forecasting' && forecastResults) {
        setTimeout(renderForecastChart, 100);
      }
    }

    // ========== Selection Mode ==========
    function setSelectionMode(mode) {
      selectionMode = mode;
      document.getElementById('mode-gemma').classList.toggle('active', mode === 'gemma');
      document.getElementById('mode-manual').classList.toggle('active', mode === 'manual');
      document.getElementById('gemma-mode-panel').style.display = mode === 'gemma' ? 'block' : 'none';
      document.getElementById('manual-mode-panel').style.display = mode === 'manual' ? 'block' : 'none';
      log('Selection mode: ' + (mode === 'gemma' ? 'ğŸ¤– Gemma AI' : 'âœ‹ Manual'), 'info');
    }

    // ========== Column Selection Helpers ==========
    function populateColumnSelectors() {
      const targetSelect = document.getElementById('target-select');
      const featureGrid = document.getElementById('feature-grid');

      // Populate target dropdown
      targetSelect.innerHTML = '<option value="">-- Select target column --</option>' +
        uploadedColumns.map(col => '<option value="' + col + '">' + col + '</option>').join('');

      // Populate feature checkboxes
      featureGrid.innerHTML = uploadedColumns.map(col =>
        '<label class="feature-checkbox" data-column="' + col + '" onclick="toggleFeature(this)">' +
        '<input type="checkbox" value="' + col + '">' +
        '<span class="checkbox-custom"></span>' +
        '<span class="feature-label" title="' + col + '">' + col + '</span>' +
        '</label>'
      ).join('');

      updateFeatureCount();
    }

    function onTargetChange() {
      manualTarget = document.getElementById('target-select').value;
      // Remove target from feature selections
      if (manualTarget) {
        const featureCheckbox = document.querySelector('.feature-checkbox[data-column="' + manualTarget + '"]');
        if (featureCheckbox && featureCheckbox.classList.contains('selected')) {
          featureCheckbox.classList.remove('selected');
          featureCheckbox.querySelector('input').checked = false;
          manualFeatures = manualFeatures.filter(f => f !== manualTarget);
        }
      }
      updateFeatureCount();
      log('Target column set: ' + (manualTarget || '(none)'), 'info');
    }

    function toggleFeature(checkbox) {
      const column = checkbox.dataset.column;
      if (column === manualTarget) {
        log('Cannot select target column as a feature', 'warning');
        return;
      }
      checkbox.classList.toggle('selected');
      const input = checkbox.querySelector('input');
      input.checked = !input.checked;
      if (input.checked) {
        if (!manualFeatures.includes(column)) manualFeatures.push(column);
      } else {
        manualFeatures = manualFeatures.filter(f => f !== column);
      }
      updateFeatureCount();
    }

    function selectAllFeatures() {
      const checkboxes = document.querySelectorAll('#feature-grid .feature-checkbox');
      manualFeatures = [];
      checkboxes.forEach(cb => {
        const column = cb.dataset.column;
        if (column && column !== manualTarget) {
          cb.classList.add('selected');
          const input = cb.querySelector('input');
          if (input) input.checked = true;
          manualFeatures.push(column);
        }
      });
      updateFeatureCount();
    }

    function deselectAllFeatures() {
      const checkboxes = document.querySelectorAll('#feature-grid .feature-checkbox');
      checkboxes.forEach(cb => {
        cb.classList.remove('selected');
        const input = cb.querySelector('input');
        if (input) input.checked = false;
      });
      manualFeatures = [];
      updateFeatureCount();
    }

    function updateFeatureCount() {
      const count = manualFeatures.length;
      document.getElementById('feature-count').textContent = count + ' feature' + (count !== 1 ? 's' : '') + ' selected';
    }

    // Timing tracking for log entries
    let logTimingStart = null;
    let lastLogTime = Date.now();

    function log(msg, type = 'info', duration = null) {
      const ts = new Date().toLocaleTimeString();
      const icons = { info: 'â„¹ï¸', success: 'âœ…', error: 'âŒ', warning: 'âš ï¸' };
      const entry = document.createElement('div');
      entry.className = 'log-entry';

      // Calculate time since last log if no duration provided
      const now = Date.now();
      let timingStr = '';
      if (duration !== null) {
        timingStr = '<span class="log-timing">(' + formatDuration(duration) + ')</span>';
      } else if (lastLogTime && type !== 'info') {
        const elapsed = now - lastLogTime;
        if (elapsed > 100) {
          timingStr = '<span class="log-timing">(+' + formatDuration(elapsed) + ')</span>';
        }
      }
      lastLogTime = now;

      entry.innerHTML = '<span class="log-time">[' + ts + ']</span> ' + (icons[type] || '') + ' <span class="log-message">' + msg + '</span>' + timingStr;
      el.log.appendChild(entry);
      el.log.scrollTop = el.log.scrollHeight;
    }

    // Format duration in human-readable format
    function formatDuration(ms) {
      if (ms < 1000) return ms + 'ms';
      if (ms < 60000) return (ms / 1000).toFixed(2) + 's';
      const mins = Math.floor(ms / 60000);
      const secs = ((ms % 60000) / 1000).toFixed(1);
      return mins + 'm ' + secs + 's';
    }

    // Start timing for an operation
    function startTiming() {
      logTimingStart = Date.now();
      lastLogTime = Date.now();
      return logTimingStart;
    }

    // Get elapsed time since timing started
    function getElapsedTime() {
      return logTimingStart ? Date.now() - logTimingStart : 0;
    }

    // ========== Engine Category Switching ==========
    let currentEngineCategory = 'all';

    function switchEngineCategory(category) {
      currentEngineCategory = category;

      // Update tab buttons
      document.querySelectorAll('.engine-category-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      event.target.closest('.engine-category-btn').classList.add('active');

      // Show/hide category content
      document.querySelectorAll('.engine-category-content').forEach(content => {
        content.classList.remove('active');
      });
      const targetContent = document.getElementById('category-' + category);
      if (targetContent) {
        targetContent.classList.add('active');
      }
    }

    // Update category stats
    function updateCategoryStats() {
      const categories = ['all', 'ml', 'financial', 'operations', 'advanced'];

      categories.forEach(cat => {
        const container = document.getElementById((cat === 'all' ? 'all' : cat) + '-engines-results');
        if (!container) return;

        const cards = container.querySelectorAll('.engine-result-card');
        let success = 0, error = 0, pending = 0;

        cards.forEach(card => {
          const status = card.querySelector('.engine-status');
          if (status) {
            if (status.classList.contains('success')) success++;
            else if (status.classList.contains('error')) error++;
            else pending++;
          }
        });

        const successEl = document.getElementById(cat + '-success-count');
        const errorEl = document.getElementById(cat + '-error-count');
        const pendingEl = document.getElementById(cat + '-pending-count');

        if (successEl) successEl.textContent = 'âœ“ ' + success;
        if (errorEl) errorEl.textContent = 'âœ— ' + error;
        if (pendingEl) pendingEl.textContent = 'â³ ' + pending;
      });
    }

    function setStatus(text, type, percent) {
      el.statusBar.className = 'status-bar ' + (type || '');
      if (type === 'loading') {
        el.statusBar.innerHTML = '<div class="spinner"></div><span>' + text + '</span>';
      } else {
        const icons = { success: 'âœ…', error: 'âŒ' };
        el.statusBar.innerHTML = '<span>' + (icons[type] || '') + ' ' + text + '</span>';
      }
      if (percent !== undefined) el.progressFill.style.width = percent + '%';
    }

    function errorToString(err) {
      if (!err) return 'Unknown error';
      if (typeof err === 'string') return err;
      if (err.message) return err.message;
      if (err.detail) return errorToString(err.detail);
      if (err.error) return errorToString(err.error);
      try { return JSON.stringify(err); } catch (e) { return String(err); }
    }

    el.uploadArea.addEventListener('dragover', function (e) { e.preventDefault(); el.uploadArea.classList.add('dragover'); });
    el.uploadArea.addEventListener('dragleave', function () { el.uploadArea.classList.remove('dragover'); });
    el.uploadArea.addEventListener('drop', function (e) { e.preventDefault(); el.uploadArea.classList.remove('dragover'); if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]); });
    el.fileInput.addEventListener('change', function (e) { if (e.target.files[0]) handleFile(e.target.files[0]); });

    async function handleFile(file) {
      setStatus('Uploading ' + file.name + '...', 'loading', 20);
      log('Uploading: ' + file.name);
      const formData = new FormData();
      formData.append('file', file);
      try {
        const res = await fetch(API_BASE + '/upload', { method: 'POST', body: formData, credentials: 'include' });
        const data = await res.json();
        if (data.error || data.detail) throw new Error(errorToString(data.error || data.detail));
        uploadedFilename = data.filename;
        uploadedColumns = data.columns || [];
        setStatus('âœ… Upload successful! Ready to analyze.', 'success', 100);
        log(`File uploaded: ${data.filename} (${data.rows} rows, ${data.columns.length} cols)`, 'success');
        el.analyzeBtn.disabled = false;
        el.uploadArea.innerHTML = '<div class="upload-icon">ğŸ“„</div><div class="upload-text">' + uploadedFilename + '</div><div class="upload-hint">' + (data.columns?.length || '?') + ' columns â€¢ ' + (data.row_count?.toLocaleString() || '?') + ' rows</div>';
        log('Upload complete: ' + uploadedFilename, 'success');

        // Show column selection card and populate it
        document.getElementById('column-selection-section').classList.add('visible');
        populateColumnSelectors();
        // Reset selections
        manualTarget = null;
        manualFeatures = [];
        excludedTargets = [];  // Reset excluded targets for new file
        forecastResults = null;  // Reset forecast results
        hasTimeColumn = false;
        selectionMode = 'gemma';
        setSelectionMode('gemma');

        // Detect time columns for forecasting
        if (detectTimeColumns()) {
          log('ğŸ”® Time-series forecasting available after analysis', 'info');
        }

        log('Column selection available - Choose Gemma AI or Manual mode', 'info');
      } catch (err) {
        setStatus('Upload failed: ' + err.message, 'error', 0);
        log('Upload error: ' + err.message, 'error');
      }
    }

    el.analyzeBtn.addEventListener('click', testAllEngines);

    async function askGemmaForColumns() {
      // Ask Gemma to analyze the columns and recommend target + features
      // Filter out any previously excluded targets
      const availableColumns = uploadedColumns.filter(col => !excludedTargets.includes(col));
      const columnsStr = availableColumns.map((col, i) => `${i + 1}. ${col}`).join('\n');

      // Build exclusion note if there are excluded targets
      const exclusionNote = excludedTargets.length > 0
        ? `\n\nIMPORTANT: Do NOT select these columns as the target (they were already tried and gave poor results): ${excludedTargets.join(', ')}`
        : '';

      const prompt = `You are analyzing a dataset with these columns:

${columnsStr}

Task: Select the best TARGET column for prediction (what we want to predict) and the FEATURE columns to use (input variables).

Rules:
- The target should be something meaningful to predict (not an ID)
- Features should be potential predictors of the target
- Do NOT include the target column in the features list${exclusionNote}

Respond in this EXACT format (no extra text):
target: [column name]
features: [column1, column2, column3, ...]`;

      try {
        const res = await fetch(API_BASE + '/api/public/chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(getCsrfToken() && { 'X-CSRF-Token': getCsrfToken() })
          },
          credentials: 'include',
          body: JSON.stringify({
            messages: [{ role: 'user', content: prompt }],
            max_tokens: 500
          })
        });
        const data = await res.json();
        const response = data.message || data.response || '';

        // Parse Gemma's selection
        const targetMatch = response.match(/target:\s*(.+)/i);
        const featuresMatch = response.match(/features:\s*(.+)/i);

        if (targetMatch && featuresMatch) {
          const target = targetMatch[1].trim().replace(/[\[\]"']/g, '');
          const featuresRaw = featuresMatch[1].replace(/[\[\]]/g, '').split(',').map(f => f.trim().replace(/["']/g, ''));
          // Filter to only valid columns and remove target from features
          const features = featuresRaw.filter(f => uploadedColumns.includes(f) && f !== target);

          return { target, features, raw: response };
        }
      } catch (err) {
        console.warn('Gemma column selection failed:', err);
      }
      return null;
    }

    // Retry analysis with a different target (excludes previous poor-performing target)
    async function retryWithDifferentTarget() {
      if (!gemmaSelection?.target) return;

      // Add current target to excluded list
      if (!excludedTargets.includes(gemmaSelection.target)) {
        excludedTargets.push(gemmaSelection.target);
      }

      log('Excluding "' + gemmaSelection.target + '" and trying again...', 'warning');

      // Reset and re-run
      selectionMode = 'gemma';
      await runAnalysis();
    }

    // ========== Test All 22 Engines with Full Results Display ==========

    // Define engines globally so resume can access them
    const ALL_ENGINES = [
      // ML & Analytics (7 engines)
      { name: 'titan', display: 'Titan AutoML', icon: 'ğŸ¤–', category: 'ml' },
      { name: 'predictive', display: 'Predictive Forecasting', icon: 'ğŸ“ˆ', category: 'ml' },
      { name: 'clustering', display: 'Clustering', icon: 'ğŸ¯', category: 'ml' },
      { name: 'anomaly', display: 'Anomaly Detection', icon: 'ğŸ”', category: 'ml' },
      { name: 'statistical', display: 'Statistical Analysis', icon: 'ğŸ“Š', category: 'ml' },
      { name: 'trend', display: 'Trend Analysis', icon: 'ğŸ“‰', category: 'ml' },
      { name: 'graphs', display: 'Universal Graph', icon: 'ğŸ“ˆ', category: 'ml' },

      // Financial (12 engines)
      { name: 'cost', display: 'Cost Optimization', icon: 'ğŸ’°', category: 'financial' },
      { name: 'roi', display: 'ROI Prediction', icon: 'ğŸ’µ', category: 'financial' },
      { name: 'spend_patterns', display: 'Spend Pattern Analysis', icon: 'ğŸ’³', category: 'financial' },
      { name: 'budget_variance', display: 'Budget Variance', icon: 'ğŸ“‹', category: 'financial' },
      { name: 'profit_margins', display: 'Profit Margin Analysis', icon: 'ğŸ“Š', category: 'financial' },
      { name: 'revenue_forecasting', display: 'Revenue Forecasting', icon: 'ğŸ’¹', category: 'financial' },
      { name: 'customer_ltv', display: 'Customer LTV', icon: 'ğŸ‘¥', category: 'financial' },
      { name: 'cash_flow', display: 'Cash Flow Analysis', icon: 'ğŸ’¸', category: 'financial' },
      { name: 'inventory_optimization', display: 'Inventory Optimization', icon: 'ğŸ“¦', category: 'financial' },
      { name: 'pricing_strategy', display: 'Pricing Strategy', icon: 'ğŸ·ï¸', category: 'financial' },
      { name: 'market_basket', display: 'Market Basket Analysis', icon: 'ğŸ›’', category: 'financial' },
      { name: 'resource_utilization', display: 'Resource Utilization', icon: 'âš™ï¸', category: 'financial' },

      // Advanced (3 engines)
      { name: 'rag_evaluation', display: 'RAG Evaluation', icon: 'ğŸ”¬', category: 'advanced' },
      { name: 'chaos', display: 'Chaos Engine', icon: 'ğŸŒ€', category: 'advanced' },
      { name: 'oracle', display: 'Oracle Causality', icon: 'ğŸ”®', category: 'advanced' }
    ];

    async function testAllEngines() {
      if (!uploadedFilename) return;

      // Initialize multi-run session for tracking
      initMultiRunSession();

      // Check for saved session for this file
      const savedSession = loadSessionFromStorage();
      if (savedSession && savedSession.filename === uploadedFilename && savedSession.status === 'paused') {
        if (confirm(`Found a paused analysis for "${uploadedFilename}" with ${savedSession.completedEngines.length}/22 engines complete.\n\nResume where you left off?`)) {
          analysisSession = savedSession;
          await restoreAndResumeSession();
          return;
        }
      }

      // Start fresh session
      analysisStopped = false;
      analysisSession = {
        id: multiRunState.sessionId || `session_${Date.now()}`,
        filename: uploadedFilename,
        startedAt: new Date().toISOString(),
        stoppedAt: null,
        status: 'running',
        completedEngines: [],
        pendingEngines: ALL_ENGINES.map(e => e.name),
        results: {},
        chats: {},
        currentEngineIndex: 0
      };

      // Start timing for the entire test run
      const testStartTime = startTiming();

      // Show results section and clear previous results
      document.getElementById('all-engines-section').style.display = 'block';
      document.getElementById('engines-database-name').textContent = uploadedFilename;

      // Clear all category containers
      document.getElementById('all-engines-results').innerHTML = '';
      document.getElementById('ml-engines-results').innerHTML = '';
      document.getElementById('financial-engines-results').innerHTML = '';
      document.getElementById('operations-engines-results').innerHTML = '';
      document.getElementById('advanced-engines-results').innerHTML = '';

      // Add control buttons
      addAnalysisControls();

      // Reset and initialize performance dashboard
      resetPerformanceTracking();
      initDashboard();

      el.analyzeBtn.disabled = true;

      log('ğŸ§ª Starting comprehensive analysis with all 22 engines...', 'info');
      log(`ğŸ“ Testing on: ${uploadedFilename}`, 'info');

      setStatus('ğŸ”¬ Running comprehensive engine analysis...', 'loading', 0);

      await runEngineLoop(0);
    }

    function addAnalysisControls() {
      // Show the header control buttons
      const stopBtn = document.getElementById('stop-btn');
      const clearBtn = document.getElementById('clear-btn');
      const resumeBtn = document.getElementById('resume-btn');

      if (stopBtn) stopBtn.style.display = 'inline-block';
      if (clearBtn) clearBtn.style.display = 'inline-block';
      if (resumeBtn) resumeBtn.style.display = 'none';
    }

    function hideAnalysisControls() {
      const stopBtn = document.getElementById('stop-btn');
      const clearBtn = document.getElementById('clear-btn');
      const resumeBtn = document.getElementById('resume-btn');

      if (stopBtn) stopBtn.style.display = 'none';
      if (clearBtn) clearBtn.style.display = 'none';
      if (resumeBtn) resumeBtn.style.display = 'none';
    }

    function clearAnalysisPage() {
      if (!confirm('Clear all analysis results and saved data for this session?')) return;

      clearSessionStorage();
      analysisStopped = true;

      // Clear UI
      document.getElementById('all-engines-results').innerHTML = '';
      document.getElementById('ml-engines-results').innerHTML = '';
      document.getElementById('financial-engines-results').innerHTML = '';
      document.getElementById('operations-engines-results').innerHTML = '';
      document.getElementById('advanced-engines-results').innerHTML = '';

      document.getElementById('engines-progress').textContent = '0/22';
      document.getElementById('engines-status').textContent = 'Cleared';
      document.getElementById('engines-total-time').textContent = '0.0s';

      // Hide control buttons
      hideAnalysisControls();

      el.analyzeBtn.disabled = false;

      log('ğŸ—‘ï¸ Analysis page cleared', 'info');
    }

    async function restoreAndResumeSession() {
      // Show results section
      document.getElementById('all-engines-section').style.display = 'block';
      document.getElementById('engines-database-name').textContent = analysisSession.filename;

      // Clear containers first
      document.getElementById('all-engines-results').innerHTML = '';
      document.getElementById('ml-engines-results').innerHTML = '';
      document.getElementById('financial-engines-results').innerHTML = '';
      document.getElementById('operations-engines-results').innerHTML = '';
      document.getElementById('advanced-engines-results').innerHTML = '';

      addAnalysisControls();
      resetPerformanceTracking();

      // Restore completed engine cards
      for (const engineName of analysisSession.completedEngines) {
        const engine = ALL_ENGINES.find(e => e.name === engineName);
        if (!engine) continue;

        const idx = ALL_ENGINES.indexOf(engine);
        const card = createEngineCard(engine, idx);
        const cardClone = card.cloneNode(true);

        document.getElementById('all-engines-results').appendChild(card);
        document.getElementById(engine.category + '-engines-results').appendChild(cardClone);

        const savedResult = analysisSession.results[engineName];
        if (savedResult) {
          displayEngineResults(card, savedResult);
          displayEngineResults(cardClone, savedResult);
          updateEngineCardStatus(card, savedResult.status === 'success' ? 'success' : 'error');
          updateEngineCardStatus(cardClone, savedResult.status === 'success' ? 'success' : 'error');

          // Restore chat messages
          restoreChatMessages(engineName, card);
          restoreChatMessages(engineName, cardClone);
        }
      }

      // Update progress display
      document.getElementById('engines-progress').textContent = `${analysisSession.completedEngines.length}/22`;
      document.getElementById('engines-status').textContent = 'Restored - Ready to resume';

      log(`ğŸ”„ Restored session with ${analysisSession.completedEngines.length}/22 engines complete`, 'info');

      el.analyzeBtn.disabled = true;
      analysisStopped = false;
      analysisSession.status = 'running';

      // Continue from where we left off
      await runEngineLoop(analysisSession.currentEngineIndex);
    }

    function restoreChatMessages(engineName, card) {
      const chats = analysisSession.chats[engineName];
      if (!chats || chats.length === 0) return;

      const messagesDiv = card.querySelector('.followup-messages');
      if (!messagesDiv) return;

      chats.forEach(chat => {
        messagesDiv.innerHTML += `
          <div class="followup-msg ${chat.role === 'user' ? 'user' : 'assistant'}">
            <span class="msg-label">${chat.role === 'user' ? 'You:' : 'ğŸ¤– Gemma:'}</span>
            <span class="msg-text">${chat.message}</span>
          </div>
        `;
      });
    }

    async function continueTestAllEngines() {
      await runEngineLoop(analysisSession.currentEngineIndex);
    }

    async function runEngineLoop(startIndex) {
      const allEngines = ALL_ENGINES;

      // Track stats per category
      const categoryStats = {
        all: { success: analysisSession.completedEngines.length, error: 0, pending: allEngines.length - analysisSession.completedEngines.length },
        ml: { success: 0, error: 0, pending: 7 },
        financial: { success: 0, error: 0, pending: 8 },
        operations: { success: 0, error: 0, pending: 4 },
        advanced: { success: 0, error: 0, pending: 3 }
      };

      // Recalculate stats from completed
      analysisSession.completedEngines.forEach(name => {
        const engine = allEngines.find(e => e.name === name);
        if (engine) {
          const result = analysisSession.results[name];
          if (result && result.status === 'success') {
            categoryStats[engine.category].success++;
          } else {
            categoryStats[engine.category].error++;
          }
          categoryStats[engine.category].pending--;
        }
      });

      for (let i = startIndex; i < allEngines.length; i++) {
        // Check if stopped
        if (analysisStopped) {
          analysisSession.currentEngineIndex = i;
          saveSessionToStorage();
          log(`â¸ï¸ Analysis paused at engine ${i + 1}/22`, 'warning');
          return;
        }

        const engine = allEngines[i];

        // Skip if already completed
        if (analysisSession.completedEngines.includes(engine.name)) {
          continue;
        }

        const engineStartTime = performance.now();
        const progress = Math.round(((i + 1) / allEngines.length) * 100);

        // Update progress with timing
        const elapsedTotal = formatDuration(getElapsedTime());
        document.getElementById('engines-progress').textContent = `${i + 1}/22`;
        document.getElementById('engines-status').textContent = `Running ${engine.display}...`;
        document.getElementById('engines-total-time').textContent = elapsedTotal;

        // Create and add card to both "all" and category-specific containers
        const card = createEngineCard(engine, i);
        const cardClone = card.cloneNode(true);

        document.getElementById('all-engines-results').appendChild(card);
        document.getElementById(engine.category + '-engines-results').appendChild(cardClone);

        // Update card status to running
        updateEngineCardStatus(card, 'running');
        updateEngineCardStatus(cardClone, 'running');

        try {
          setStatus(`Testing ${engine.display}... (${i + 1}/22) - ${elapsedTotal}`, 'loading', progress);
          log(`â³ Running ${engine.display}...`, 'info');

          // Call engine API using new dynamic endpoint
          const endpoint = `/analytics/run-engine/${engine.name}`;

          const res = await fetch(API_BASE + endpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              ...(getCsrfToken() && { 'X-CSRF-Token': getCsrfToken() })
            },
            credentials: 'include',
            body: JSON.stringify({
              filename: uploadedFilename,
              target_column: null,
              config: null,
              use_vectorization: document.getElementById('use-vectors') ? document.getElementById('use-vectors').checked : false
            })
          });

          const data = await res.json();
          const engineDuration = performance.now() - engineStartTime;

          if (data) {
            // Get Gemma summary
            log(`ğŸ¤– Getting Gemma summary for ${engine.display}...`, 'info');
            const summary = await getGemmaSummary(engine.name, engine.display, data);

            // Log detailed explanation in activity log with timing
            log(`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`, 'info');
            log(`âœ… ${engine.display} - Analysis Complete`, 'success', engineDuration);
            log(`ğŸ“ Summary: ${summary}`, 'info');

            // Log key findings
            const keyFindings = extractKeyFindings(data);
            if (keyFindings.length > 0) {
              keyFindings.forEach(finding => log(`   â€¢ ${finding}`, 'info'));
            }

            const dataSize = JSON.stringify(data).length;
            log(`ğŸ“¦ Data produced: ${dataSize.toLocaleString()} bytes`, 'info');
            log(`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`, 'info');

            // Display results in both cards
            const result = {
              status: 'success',
              data: data,
              gemmaSummary: summary,
              dataSize: dataSize,
              duration: engineDuration,
              targetColumn: manualTarget || gemmaSelection?.target || 'auto'
            };
            displayEngineResults(card, result);
            displayEngineResults(cardClone, result);

            const finalStatus = data.status === 'requires_time_data' || data.status === 'requires_target_data' ? 'fallback' : 'success';
            updateEngineCardStatus(card, finalStatus);
            updateEngineCardStatus(cardClone, finalStatus);

            // ========== SAVE TO MULTI-RUN STATE ==========
            const targetCol = manualTarget || gemmaSelection?.target || 'auto';
            addRunToState(engine.name, targetCol, result);

            // Add run navigation to card header after EVERY run (including first)
            const cardHeader = card.querySelector('.engine-card-header');
            const cardCloneHeader = cardClone.querySelector('.engine-card-header');
            if (cardHeader) {
              const existingNav = cardHeader.querySelector('.run-nav');
              if (existingNav) existingNav.remove();
              cardHeader.insertAdjacentHTML('beforeend', createRunNavigation(engine.name));
            }
            if (cardCloneHeader) {
              const existingNav = cardCloneHeader.querySelector('.run-nav');
              if (existingNav) existingNav.remove();
              cardCloneHeader.insertAdjacentHTML('beforeend', createRunNavigation(engine.name));
            }
            // ========== END MULTI-RUN SAVE ==========

            // Update category stats
            categoryStats.all.success++;
            categoryStats.all.pending--;
            categoryStats[engine.category].success++;
            categoryStats[engine.category].pending--;

            // Track performance for dashboard
            trackEnginePerformance(engine, engineDuration, 'success', dataSize);

            // Save to session
            analysisSession.results[engine.name] = result;
            analysisSession.completedEngines.push(engine.name);
            analysisSession.pendingEngines = analysisSession.pendingEngines.filter(n => n !== engine.name);
            analysisSession.currentEngineIndex = i + 1;
            saveSessionToStorage();
          }
        } catch (err) {
          const engineDuration = performance.now() - engineStartTime;
          log(`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`, 'info');
          log(`âŒ ${engine.display} - Failed`, 'error', engineDuration);
          log(`   Error: ${err.message}`, 'error');
          log(`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`, 'info');

          const errorResult = {
            status: 'error',
            error: err.message,
            duration: engineDuration
          };
          displayEngineResults(card, errorResult);
          displayEngineResults(cardClone, errorResult);
          updateEngineCardStatus(card, 'error');
          updateEngineCardStatus(cardClone, 'error');

          // Update category stats
          categoryStats.all.error++;
          categoryStats.all.pending--;
          categoryStats[engine.category].error++;
          categoryStats[engine.category].pending--;

          // Track performance for dashboard
          trackEnginePerformance(engine, engineDuration, 'error', 0);

          // Save error to session
          analysisSession.results[engine.name] = errorResult;
          analysisSession.completedEngines.push(engine.name);
          analysisSession.currentEngineIndex = i + 1;
          saveSessionToStorage();
        }

        // Update category stats display
        updateCategoryStatsDisplay(categoryStats);

        // Small delay for UI updates
        await new Promise(r => setTimeout(r, 100));
      }

      // Final status with total timing
      const totalTime = formatDuration(getElapsedTime());
      document.getElementById('engines-status').textContent = 'Complete!';
      document.getElementById('engines-total-time').textContent = totalTime;

      analysisSession.status = 'completed';
      saveSessionToStorage();

      // Hide stop button, keep clear visible
      const stopBtn = document.getElementById('stop-btn');
      const resumeBtn = document.getElementById('resume-btn');
      if (stopBtn) stopBtn.style.display = 'none';
      if (resumeBtn) resumeBtn.style.display = 'none';

      log('', 'info');
      log(`ğŸ‰ All 22 engines analysis complete!`, 'success', getElapsedTime());
      log(`ğŸ“Š Results: ${categoryStats.all.success} succeeded, ${categoryStats.all.error} failed`, 'info');
      setStatus(`âœ… Test complete: All 22 engines analyzed in ${totalTime}`, 'success', 100);

      el.analyzeBtn.disabled = false;
    }

    function createEngineCard(engine, index) {
      const card = document.createElement('div');
      card.className = 'engine-result-card';
      card.id = `engine-card-${engine.name}`;
      card.innerHTML = `
        <div class="engine-card-header" onclick="toggleEngineCard('${engine.name}')">
          <span class="engine-icon">${engine.icon}</span>
          <h3>${index + 1}. ${engine.display}</h3>
          <span class="engine-status" id="status-${engine.name}">â³ Pending</span>
        </div>
        <div class="engine-card-body" id="body-${engine.name}">
          <div class="loading-spinner">â³ Waiting to run...</div>
        </div>
      `;
      return card;
    }

    function toggleEngineCard(engineName) {
      // Toggle all cards with this engine name (in all categories)
      const cards = document.querySelectorAll(`[id^="engine-card-${engineName}"]`);
      cards.forEach(card => card.classList.toggle('expanded'));
    }

    function toggleFullResults(id) {
      const content = document.getElementById(id);
      const icon = document.getElementById('icon-' + id);
      if (content && icon) {
        const isHidden = content.style.display === 'none';
        content.style.display = isHidden ? 'block' : 'none';
        icon.textContent = isHidden ? 'â–¼' : 'â–¶';
      }
    }

    // Get cluster color for consistent styling
    function getClusterColor(clusterId) {
      const colors = ['#06b6d4', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899', '#14b8a6', '#f97316'];
      return colors[clusterId % colors.length];
    }

    // Highlight a specific cluster in the 3D plot
    function highlightCluster(clusterId, vizId) {
      const container = document.getElementById(`cluster-${vizId}`);
      if (!container) return;

      // Update cluster card selection
      const cards = document.querySelectorAll('.cluster-card');
      cards.forEach(card => {
        card.classList.remove('selected');
        if (parseInt(card.dataset.cluster) === clusterId) {
          card.classList.add('selected');
        }
      });

      // Animate the Plotly trace for this cluster
      try {
        const plotData = container.data;
        if (!plotData) return;

        const newOpacities = plotData.map((trace, i) => {
          if (trace.name && trace.name.includes(`Cluster ${clusterId + 1}`)) {
            return { 'marker.opacity': 1.0, 'marker.size': 7 };
          }
          return { 'marker.opacity': 0.3, 'marker.size': 4 };
        });

        Plotly.animate(container, {
          data: newOpacities
        }, { transition: { duration: 300 } });

        // Reset after 3 seconds
        setTimeout(() => {
          Plotly.animate(container, {
            data: plotData.map(() => ({ 'marker.opacity': 0.85, 'marker.size': 4 }))
          }, { transition: { duration: 300 } });
        }, 3000);
      } catch (e) {
        console.log('Cluster highlight animation not supported');
      }
    }

    // ========== SESSION PERSISTENCE FUNCTIONS ==========
    const SESSION_STORAGE_KEY = 'nemo_analysis_session';

    function saveSessionToStorage() {
      try {
        localStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(analysisSession));
      } catch (e) {
        console.warn('Could not save session to localStorage:', e);
      }
    }

    function loadSessionFromStorage() {
      try {
        const saved = localStorage.getItem(SESSION_STORAGE_KEY);
        if (saved) {
          const parsed = JSON.parse(saved);
          // Only restore if it's the same file and has data
          if (parsed && parsed.filename && Object.keys(parsed.results).length > 0) {
            return parsed;
          }
        }
      } catch (e) {
        console.warn('Could not load session from localStorage:', e);
      }
      return null;
    }

    function clearSessionStorage() {
      try {
        localStorage.removeItem(SESSION_STORAGE_KEY);
        analysisSession = {
          id: null,
          filename: null,
          startedAt: null,
          stoppedAt: null,
          status: 'idle',
          completedEngines: [],
          pendingEngines: [],
          results: {},
          chats: {},
          currentEngineIndex: 0
        };
        analysisStopped = false;
      } catch (e) {
        console.warn('Could not clear session storage:', e);
      }
    }

    function saveChatMessage(engineName, role, message) {
      if (!analysisSession.chats[engineName]) {
        analysisSession.chats[engineName] = [];
      }
      analysisSession.chats[engineName].push({
        role,
        message,
        timestamp: new Date().toISOString()
      });
      saveSessionToStorage();
    }

    function stopAnalysis() {
      analysisStopped = true;
      analysisSession.status = 'paused';
      analysisSession.stoppedAt = new Date().toISOString();
      saveSessionToStorage();

      // Update header buttons
      const stopBtn = document.getElementById('stop-btn');
      const resumeBtn = document.getElementById('resume-btn');

      if (stopBtn) stopBtn.style.display = 'none';
      if (resumeBtn) resumeBtn.style.display = 'inline-block';

      const statusEl = document.getElementById('engines-status');
      if (statusEl) {
        statusEl.textContent = 'Paused - Click Resume to continue';
        statusEl.style.color = '#f59e0b';
      }

      log('â¸ï¸ Analysis paused. Click Resume to continue.', 'warning');
    }

    // ========== MULTI-RUN TRACKING SYSTEM ==========
    // Stores all runs for navigation and comparison
    const multiRunState = {
      runs: {},           // { engineName: [{ runId, targetColumn, result, timestamp }] }
      currentIndex: {},   // { engineName: 0 }
      sessionId: null,
      MAX_RUNS: 20
    };

    function initMultiRunSession() {
      if (!multiRunState.sessionId) {
        multiRunState.sessionId = `session_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
      }
      return multiRunState.sessionId;
    }

    function addRunToState(engineName, targetColumn, result) {
      if (!multiRunState.runs[engineName]) {
        multiRunState.runs[engineName] = [];
      }

      const run = {
        runId: `run_${Date.now()}_${Math.random().toString(36).substring(2, 6)}`,
        targetColumn: targetColumn,
        result: result,
        timestamp: new Date().toISOString()
      };

      // Add to beginning (newest first)
      multiRunState.runs[engineName].unshift(run);

      // Enforce 20 run limit
      if (multiRunState.runs[engineName].length > multiRunState.MAX_RUNS) {
        multiRunState.runs[engineName] = multiRunState.runs[engineName].slice(0, multiRunState.MAX_RUNS);
      }

      // Set current to newest
      multiRunState.currentIndex[engineName] = 0;

      // Update run count display
      updateRunCountDisplay();

      // Save to backend
      saveRunToBackend(engineName, run);

      return run;
    }

    async function saveRunToBackend(engineName, run) {
      try {
        await fetch(API_BASE + '/analytics/history/save-run', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(getCsrfToken() && { 'X-CSRF-Token': getCsrfToken() })
          },
          credentials: 'include',
          body: JSON.stringify({
            session_id: multiRunState.sessionId,
            engine_name: engineName,
            target_column: run.targetColumn,
            filename: uploadedFilename,
            result: run.result,
            run_id: run.runId
          })
        });
      } catch (err) {
        console.warn('Failed to save run to backend:', err);
      }
    }

    function getUsedTargets() {
      const used = new Set();
      Object.values(multiRunState.runs).forEach(engineRuns => {
        engineRuns.forEach(run => {
          if (run.targetColumn) {
            used.add(run.targetColumn);
          }
        });
      });
      return Array.from(used);
    }

    function getRemainingColumns() {
      const usedTargets = getUsedTargets();
      const allColumns = uploadedColumns || [];
      return allColumns.filter(col => !usedTargets.includes(col));
    }

    function updateRunCountDisplay() {
      const totalRuns = Object.values(multiRunState.runs).reduce((sum, runs) => sum + runs.length, 0);
      const remaining = getRemainingColumns().length;

      const totalEl = document.getElementById('total-runs-count');
      const remainingEl = document.getElementById('remaining-columns-count');
      const actionsBar = document.getElementById('multi-run-actions');
      const compareBtn = document.getElementById('compare-runs-btn');

      if (totalEl) totalEl.textContent = totalRuns;
      if (remainingEl) remainingEl.textContent = remaining > 0 ? `(${remaining} columns left!)` : '(done!)';
      if (actionsBar) actionsBar.style.display = totalRuns > 0 ? 'flex' : 'none';
      if (compareBtn) compareBtn.disabled = totalRuns < 2;
    }

    function getNavigationDisplay(engineName) {
      const runs = multiRunState.runs[engineName] || [];
      if (runs.length === 0) return '';
      const idx = multiRunState.currentIndex[engineName] || 0;
      return `${idx + 1} of ${runs.length}`;
    }

    function navigateRun(engineName, direction) {
      const runs = multiRunState.runs[engineName] || [];
      let idx = multiRunState.currentIndex[engineName] || 0;

      if (direction === 'prev' && idx < runs.length - 1) {
        idx++;
      } else if (direction === 'next' && idx > 0) {
        idx--;
      }

      multiRunState.currentIndex[engineName] = idx;
      const run = runs[idx];

      if (run) {
        displayRunInCard(engineName, run);
        updateNavigationButtons(engineName);
        log(`ğŸ“Š Viewing run ${idx + 1} of ${runs.length} for ${engineName}: target "${run.targetColumn}"`, 'info');
      }
    }

    function displayRunInCard(engineName, run) {
      // Find all cards for this engine
      const cards = document.querySelectorAll(`[id^="engine-card-${engineName}"]`);
      cards.forEach(card => {
        const result = {
          status: 'success',
          data: run.result,
          gemmaSummary: run.result.gemmaSummary || 'Summary available',
          dataSize: JSON.stringify(run.result).length,
          duration: run.result.duration || 0
        };
        displayEngineResults(card, result);
      });
    }

    function updateNavigationButtons(engineName) {
      const runs = multiRunState.runs[engineName] || [];
      const idx = multiRunState.currentIndex[engineName] || 0;

      document.querySelectorAll(`.run-nav[data-engine="${engineName}"]`).forEach(nav => {
        const prevBtn = nav.querySelector('.nav-prev');
        const nextBtn = nav.querySelector('.nav-next');
        const counter = nav.querySelector('.run-counter');

        if (prevBtn) prevBtn.disabled = idx >= runs.length - 1;
        if (nextBtn) nextBtn.disabled = idx <= 0;
        if (counter) counter.textContent = `${idx + 1} of ${runs.length}`;
      });
    }

    function createRunNavigation(engineName) {
      const runs = multiRunState.runs[engineName] || [];
      if (runs.length === 0) return '';

      const idx = multiRunState.currentIndex[engineName] || 0;
      const showNavArrows = runs.length > 1;

      return `
        <div class="run-nav" data-engine="${engineName}">
          ${showNavArrows ? `
            <button class="nav-prev" onclick="event.stopPropagation(); navigateRun('${engineName}', 'prev')" ${idx >= runs.length - 1 ? 'disabled' : ''}>â—€</button>
            <span class="run-counter">${idx + 1} of ${runs.length}</span>
            <button class="nav-next" onclick="event.stopPropagation(); navigateRun('${engineName}', 'next')" ${idx <= 0 ? 'disabled' : ''}>â–¶</button>
          ` : `
            <span class="run-counter">Run 1</span>
          `}
          <button class="rerun-single" onclick="event.stopPropagation(); rerunSingleEngine('${engineName}')" title="Rerun with different target">ğŸ”„ Rerun</button>
        </div>
      `;
    }

    async function testAgain() {
      const remaining = getRemainingColumns();

      if (remaining.length === 0) {
        alert('All columns have been analyzed! Upload a new dataset to test more.');
        return;
      }

      log(`ğŸ”„ Test Again: ${remaining.length} columns remaining to analyze`, 'info');

      try {
        // Ask Gemma to select the next target
        const response = await fetch(API_BASE + '/analytics/test-again', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(getCsrfToken() && { 'X-CSRF-Token': getCsrfToken() })
          },
          credentials: 'include',
          body: JSON.stringify({
            session_id: multiRunState.sessionId,
            filename: uploadedFilename,
            all_columns: uploadedColumns,
            used_targets: getUsedTargets()
          })
        });

        if (!response.ok) throw new Error('Test Again failed');

        const data = await response.json();
        log(`ğŸ¤– Gemma selected new target: "${data.target_column}"`, 'info');

        // Set the new target and run analysis
        manualTarget = data.target_column;
        excludedTargets.push(data.target_column);

        // Run the full engine test with new target
        await testAllEngines();

      } catch (err) {
        log(`âŒ Test Again failed: ${err.message}`, 'error');
        alert('Test Again failed: ' + err.message);
      }
    }

    async function rerunSingleEngine(engineName) {
      const remaining = getRemainingColumns();

      if (remaining.length === 0) {
        alert('All columns have been analyzed! Upload a new dataset.');
        return;
      }

      log(`ğŸ”„ Rerunning ${engineName}...`, 'info');

      // Find the engine
      const engine = ALL_ENGINES.find(e => e.name === engineName);
      if (!engine) {
        log(`âŒ Engine ${engineName} not found`, 'error');
        return;
      }

      // Update card to show loading
      const cards = document.querySelectorAll(`[id^="engine-card-${engineName}"]`);
      cards.forEach(card => {
        updateEngineCardStatus(card, 'running');
        const body = card.querySelector('.engine-card-body');
        if (body) body.innerHTML = '<div class="loading-spinner">ğŸ¤– Selecting new target...</div>';
      });

      try {
        // Ask Gemma to select new target for this engine
        const response = await fetch(API_BASE + '/analytics/rerun', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(getCsrfToken() && { 'X-CSRF-Token': getCsrfToken() })
          },
          credentials: 'include',
          body: JSON.stringify({
            session_id: multiRunState.sessionId,
            engine_name: engineName,
            filename: uploadedFilename,
            all_columns: uploadedColumns,
            used_targets: getUsedTargets()
          })
        });

        if (!response.ok) throw new Error('Rerun failed');

        const targetData = await response.json();
        log(`ğŸ¤– Gemma selected target: "${targetData.target_column}" for ${engineName}`, 'info');

        // Run just this engine
        const engineRes = await fetch(API_BASE + `/analytics/run-engine/${engineName}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(getCsrfToken() && { 'X-CSRF-Token': getCsrfToken() })
          },
          credentials: 'include',
          body: JSON.stringify({
            filename: uploadedFilename,
            target_column: targetData.target_column,
            config: null
          })
        });

        const engineData = await engineRes.json();

        // Get Gemma summary
        const summary = await getGemmaSummary(engineName, engine.display, engineData);

        // Create result
        const result = {
          status: 'success',
          data: engineData,
          gemmaSummary: summary,
          dataSize: JSON.stringify(engineData).length,
          duration: 0,
          targetColumn: targetData.target_column
        };

        // Add to multi-run state
        const run = addRunToState(engineName, targetData.target_column, result);

        // Display result
        cards.forEach(card => {
          displayEngineResults(card, result);
          updateEngineCardStatus(card, 'success');

          // Add/update navigation
          const header = card.querySelector('.engine-card-header');
          if (header) {
            const existingNav = header.querySelector('.run-nav');
            if (existingNav) existingNav.remove();
            header.insertAdjacentHTML('beforeend', createRunNavigation(engineName));
          }
        });

        log(`âœ… ${engine.display} rerun complete with target "${targetData.target_column}"`, 'success');

      } catch (err) {
        log(`âŒ Rerun failed for ${engineName}: ${err.message}`, 'error');
        cards.forEach(card => {
          updateEngineCardStatus(card, 'error');
          const body = card.querySelector('.engine-card-body');
          if (body) body.innerHTML = `<div class="error-message">âŒ Rerun failed: ${err.message}</div>`;
        });
      }
    }

    async function compareAllRuns() {
      const totalRuns = Object.values(multiRunState.runs).reduce((sum, runs) => sum + runs.length, 0);

      if (totalRuns < 2) {
        alert('Need at least 2 runs to compare. Run more analyses first.');
        return;
      }

      log(`ğŸ“Š Comparing ${totalRuns} runs across ${Object.keys(multiRunState.runs).length} engines...`, 'info');

      try {
        const response = await fetch(API_BASE + '/analytics/compare-runs-prompt', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(getCsrfToken() && { 'X-CSRF-Token': getCsrfToken() })
          },
          credentials: 'include',
          body: JSON.stringify({
            session_id: multiRunState.sessionId,
            runs: multiRunState.runs
          })
        });

        if (!response.ok) throw new Error('Comparison failed');

        const data = await response.json();

        // Show comparison in a modal or new section
        showComparisonResults(data);

      } catch (err) {
        log(`âŒ Comparison failed: ${err.message}`, 'error');
        alert('Comparison failed: ' + err.message);
      }
    }

    function showComparisonResults(data) {
      // Create modal for comparison results
      const modal = document.createElement('div');
      modal.className = 'comparison-modal';
      modal.innerHTML = `
        <div class="comparison-content">
          <div class="comparison-header">
            <h2>ğŸ“Š Multi-Run Comparison Analysis</h2>
            <button class="close-modal" onclick="this.closest('.comparison-modal').remove()">âœ•</button>
          </div>
          <div class="comparison-body">
            <div class="gemma-analysis">${data.analysis || data.comparison || 'Analysis complete'}</div>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
    }
    // ========== END MULTI-RUN TRACKING ==========

    async function resumeAnalysis() {
      analysisStopped = false;
      analysisSession.status = 'running';

      // Update header buttons
      const stopBtn = document.getElementById('stop-btn');
      const resumeBtn = document.getElementById('resume-btn');

      if (stopBtn) stopBtn.style.display = 'inline-block';
      if (resumeBtn) resumeBtn.style.display = 'none';

      const statusEl = document.getElementById('engines-status');
      if (statusEl) {
        statusEl.textContent = 'Resuming...';
        statusEl.style.color = '#10b981';
      }

      log('â–¶ï¸ Resuming analysis...', 'info');

      // Continue from where we left off
      await continueTestAllEngines();
    }

    // Track Gemma GPU warmup state
    let gemmaReady = false;
    let gemmaWarmingUp = false;

    // Warm up Gemma GPU when user focuses on chat input
    async function warmupGemmaForChat(inputElement, sendButton) {
      if (gemmaReady || gemmaWarmingUp) return;

      gemmaWarmingUp = true;
      sendButton.disabled = true;
      sendButton.innerHTML = 'â³';
      inputElement.placeholder = 'Loading Gemma on GPU...';

      try {
        // Send a minimal warmup request
        const response = await fetch(API_BASE + '/api/public/chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(getCsrfToken() && { 'X-CSRF-Token': getCsrfToken() })
          },
          credentials: 'include',
          body: JSON.stringify({
            messages: [{ role: 'user', content: 'Hello' }],
            max_tokens: 5
          })
        });

        if (response.ok) {
          gemmaReady = true;
          sendButton.disabled = false;
          sendButton.innerHTML = 'Ask â†’';
          inputElement.placeholder = 'Ask a follow-up question about this analysis...';
        } else {
          throw new Error('Warmup failed');
        }
      } catch (e) {
        console.warn('Gemma warmup failed:', e);
        // Still enable after 3 seconds to allow retry
        setTimeout(() => {
          gemmaReady = true;
          sendButton.disabled = false;
          sendButton.innerHTML = 'Ask â†’';
          inputElement.placeholder = 'Ask a follow-up question...';
        }, 3000);
      }
      gemmaWarmingUp = false;
    }

    // Send follow-up question to Gemma with context
    async function sendFollowupQuestion(chatId, engineName, encodedSummary, encodedData) {
      const input = document.getElementById(`${chatId}-input`);
      const messagesDiv = document.getElementById(`${chatId}-messages`);
      const sendBtn = input?.parentElement?.querySelector('.followup-btn');

      if (!input || !messagesDiv) return;

      // Check if Gemma is ready
      if (!gemmaReady) {
        input.placeholder = 'Please wait, Gemma is loading...';
        return;
      }

      const question = input.value.trim();
      if (!question) return;

      // Decode the context
      const originalSummary = decodeURIComponent(encodedSummary);
      let dataContext = '';
      try {
        dataContext = decodeURIComponent(encodedData);
      } catch (e) {
        dataContext = 'Analysis data available';
      }

      // Save user message to session
      saveChatMessage(engineName, 'user', question);

      // Add user message to chat
      messagesDiv.innerHTML += `
        <div class="followup-msg user">
          <span class="msg-label">You:</span>
          <span class="msg-text">${question}</span>
        </div>
      `;

      // Clear input and disable send
      input.value = '';
      if (sendBtn) sendBtn.disabled = true;

      // Add loading indicator
      const loadingId = `loading-${Date.now()}`;
      messagesDiv.innerHTML += `
        <div class="followup-msg assistant loading" id="${loadingId}">
          <span class="msg-label">ğŸ¤– Gemma:</span>
          <span class="msg-text">Thinking...</span>
        </div>
      `;

      // Scroll to bottom
      messagesDiv.scrollTop = messagesDiv.scrollHeight;

      try {
        // Build conversation history for context
        const chatHistory = analysisSession.chats[engineName] || [];
        const historyText = chatHistory.slice(-6).map(m =>
          `${m.role === 'user' ? 'User' : 'Assistant'}: ${m.message}`
        ).join('\n');

        // Build the full prompt
        const fullPrompt = `Context - Previous Analysis Summary:
${originalSummary}

Analysis Data:
${dataContext.substring(0, 2000)}

Conversation History:
${historyText}

User Question: ${question}

Please answer based on the analysis context. Be specific and reference the actual data.`;

        // Call Gemma with CORRECT messages format
        const response = await fetch(API_BASE + '/api/public/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({
            messages: [{ role: 'user', content: fullPrompt }],
            max_tokens: 500,
            temperature: 0.7
          })
        });

        const result = await response.json();
        const answer = result.message || result.response || result.text || result.content || 'Unable to generate response';

        // Save assistant response to session
        saveChatMessage(engineName, 'assistant', answer);

        // Remove loading and add answer
        const loadingEl = document.getElementById(loadingId);
        if (loadingEl) {
          loadingEl.remove();
        }

        messagesDiv.innerHTML += `
          <div class="followup-msg assistant">
            <span class="msg-label">ğŸ¤– Gemma:</span>
            <span class="msg-text">${renderMarkdown(answer)}</span>
          </div>
        `;

        messagesDiv.scrollTop = messagesDiv.scrollHeight;

      } catch (error) {
        console.error('Follow-up question error:', error);
        const loadingEl = document.getElementById(loadingId);
        if (loadingEl) {
          loadingEl.innerHTML = `
            <span class="msg-label">ğŸ¤– Gemma:</span>
            <span class="msg-text" style="color: #ef4444;">Error: Could not get response. Please try again.</span>
          `;
          loadingEl.classList.remove('loading');
        }
      } finally {
        if (sendBtn) sendBtn.disabled = false;
      }
    }

    function updateEngineCardStatus(card, status) {
      const statusEl = card.querySelector('.engine-status');
      if (!statusEl) return;
      statusEl.className = `engine-status ${status}`;

      const icons = {
        pending: 'â³ Pending',
        running: 'âš¡ Running',
        success: 'âœ… Complete',
        fallback: 'âš ï¸ Fallback',
        error: 'âŒ Failed'
      };

      statusEl.textContent = icons[status] || status;
    }

    // Update category stats display
    function updateCategoryStatsDisplay(stats) {
      const categories = ['all', 'ml', 'financial', 'operations', 'advanced'];

      categories.forEach(cat => {
        const successEl = document.getElementById(cat + '-success-count');
        const errorEl = document.getElementById(cat + '-error-count');
        const pendingEl = document.getElementById(cat + '-pending-count');

        if (successEl) successEl.textContent = 'âœ“ ' + stats[cat].success;
        if (errorEl) errorEl.textContent = 'âœ— ' + stats[cat].error;
        if (pendingEl) pendingEl.textContent = 'â³ ' + stats[cat].pending;
      });
    }

    function displayEngineResults(card, result) {
      const bodyEl = card.querySelector('.engine-card-body');
      if (!bodyEl) return;

      // Format duration if available
      const durationStr = result.duration ? formatDuration(result.duration) : '';
      const durationBadge = durationStr ? `<span style="background: rgba(6,182,212,0.2); color: #67e8f9; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; margin-left: 8px;">â±ï¸ ${durationStr}</span>` : '';

      if (result.status === 'success') {
        const jsonStr = JSON.stringify(result.data).replace(/'/g, "&#39;").replace(/"/g, "&quot;");
        const uniqueId = 'full-results-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        const vizId = 'viz-' + uniqueId;

        // Determine which visualization to show based on engine type
        const engineName = card.id?.replace('engine-card-', '') || '';
        let vizSection = '';

        if (engineName === 'titan' && result.data.feature_importance) {
          vizSection = `
            <div class="engine-viz-section">
              <h5>ğŸ“Š Feature Impact Analysis</h5>
              <div class="waterfall-container" id="waterfall-${vizId}"></div>
            </div>
          `;
        } else if (engineName === 'clustering' && result.data) {
          // Build cluster profile cards
          const profiles = result.data.cluster_profiles || [];
          const pca3d = result.data.pca_3d || {};
          const componentLoadings = pca3d.component_loadings || [];

          let clusterCardsHtml = profiles.map((p, idx) => `
            <div class="cluster-card" data-cluster="${p.cluster_id}" onclick="highlightCluster(${p.cluster_id}, '${vizId}')">
              <div class="cluster-header">
                <span class="cluster-badge" style="background: ${getClusterColor(p.cluster_id)}">Cluster ${p.cluster_id + 1}</span>
                <span class="cluster-size">${p.size} pts (${p.percentage.toFixed(1)}%)</span>
              </div>
              <div class="cluster-stats">
                ${Object.entries(p.feature_stats || {}).slice(0, 3).map(([feat, stats]) => `
                  <div class="stat-row">
                    <span class="stat-name">${feat.replace(/_/g, ' ')}</span>
                    <span class="stat-value">Î¼=${stats.mean.toFixed(1)} Ïƒ=${stats.std.toFixed(1)}</span>
                  </div>
                `).join('')}
                ${Object.keys(p.feature_stats || {}).length > 3 ? '<div class="stat-more">+ more features...</div>' : ''}
              </div>
            </div>
          `).join('');

          // Build PCA explanation
          let pcaExplainHtml = '';
          if (componentLoadings.length > 0) {
            pcaExplainHtml = `
              <div class="pca-explanation">
                <h6>ğŸ”¬ What the Axes Mean</h6>
                <div class="pca-components">
                  ${componentLoadings.map(pc => `
                    <div class="pca-component">
                      <div class="pc-header">
                        <strong>${pc.component}</strong>
                        <span class="pc-variance">${(pc.variance_explained * 100).toFixed(1)}% variance</span>
                      </div>
                      <div class="pc-features">
                        ${pc.top_features.slice(0, 3).map(f => `
                          <span class="pc-feature ${f.loading > 0 ? 'positive' : 'negative'}">
                            ${f.loading > 0 ? 'â†‘' : 'â†“'} ${f.feature.replace(/_/g, ' ')}
                          </span>
                        `).join('')}
                      </div>
                    </div>
                  `).join('')}
                </div>
              </div>
            `;
          }

          vizSection = `
            <div class="engine-viz-section clustering-full">
              <div class="clustering-layout">
                <div class="clustering-main">
                  <h5>ğŸ¯ 3D Cluster Visualization</h5>
                  <div class="scatter-3d-container" id="cluster-${vizId}"></div>
                  ${pcaExplainHtml}
                </div>
                <div class="clustering-sidebar">
                  <h6>ğŸ“‹ Cluster Profiles</h6>
                  <div class="cluster-cards-container">
                    ${clusterCardsHtml || '<p style="color: #94a3b8;">No cluster profiles available</p>'}
                  </div>
                </div>
              </div>
            </div>
          `;
        } else if (engineName === 'anomaly' && result.data) {
          vizSection = `
            <div class="engine-viz-section">
              <h5>ğŸ” Anomaly Score Distribution</h5>
              <div class="anomaly-dist-container" id="anomaly-${vizId}"></div>
            </div>
          `;
        } else if (engineName === 'statistical' && result.data) {
          vizSection = `
            <div class="engine-viz-section">
              <h5>ğŸ“ˆ Statistical Overview</h5>
              <div class="boxplot-container" id="boxplot-${vizId}"></div>
            </div>
          `;
        } else if (engineName === 'cash_flow' && result.data) {
          vizSection = `
            <div class="engine-viz-section fin-viz-premium">
              <h5>ğŸ’¸ Cash Flow Analysis</h5>
              <div class="fin-grid fin-grid-2 fin-gap-md">
                <div class="fin-chart-container" id="sankey-${vizId}" style="height: 350px;"></div>
                <div class="fin-chart-container" id="cashflow-combo-${vizId}" style="height: 350px;"></div>
              </div>
              <div class="fin-chart-container" id="cashflow-gauge-${vizId}" style="height: 200px; margin-top: 1rem;"></div>
            </div>
          `;
        } else if (engineName === 'budget_variance' && result.data) {
          vizSection = `
            <div class="engine-viz-section fin-viz-premium">
              <h5>ğŸ“‹ Budget Variance Analysis</h5>
              <div class="fin-grid fin-grid-2 fin-gap-md">
                <div class="fin-chart-container" id="waterfall-${vizId}" style="height: 350px;"></div>
                <div class="fin-chart-container" id="bullet-${vizId}" style="height: 350px;"></div>
              </div>
            </div>
          `;
        } else if (engineName === 'profit_margins' && result.data) {
          vizSection = `
            <div class="engine-viz-section fin-viz-premium">
              <h5>ğŸ“Š Profit Margin Analysis</h5>
              <div class="fin-grid fin-grid-2 fin-gap-md">
                <div class="fin-chart-container" id="margin-gauge-${vizId}" style="height: 250px;"></div>
                <div class="fin-chart-container" id="margin-treemap-${vizId}" style="height: 350px;"></div>
              </div>
            </div>
          `;
        } else if (engineName === 'revenue_forecasting' && result.data) {
          vizSection = `
            <div class="engine-viz-section fin-viz-premium">
              <h5>ğŸ”® Revenue Forecast</h5>
              <div class="fin-chart-container-lg" id="forecast-${vizId}" style="height: 400px;"></div>
            </div>
          `;
        } else if (engineName === 'customer_ltv' && result.data) {
          vizSection = `
            <div class="engine-viz-section fin-viz-premium">
              <h5>ğŸ‘¥ Customer Lifetime Value</h5>
              <div class="fin-grid fin-grid-2 fin-gap-md">
                <div class="fin-chart-container" id="ltv-radar-${vizId}" style="height: 350px;"></div>
                <div class="fin-chart-container" id="ltv-kpi-${vizId}" style="height: 350px;"></div>
              </div>
            </div>
          `;
        } else if (engineName === 'cost' && result.data) {
          vizSection = `
            <div class="engine-viz-section fin-viz-premium">
              <h5>ğŸ’° Cost Optimization</h5>
              <div class="fin-grid fin-grid-2 fin-gap-md">
                <div class="fin-chart-container" id="cost-treemap-${vizId}" style="height: 350px;"></div>
                <div class="fin-chart-container" id="cost-pareto-${vizId}" style="height: 350px;"></div>
              </div>
            </div>
          `;
        } else if (engineName === 'roi' && result.data) {
          vizSection = `
            <div class="engine-viz-section fin-viz-premium">
              <h5>ğŸ“ˆ ROI Prediction</h5>
              <div class="fin-grid fin-grid-2 fin-gap-md">
                <div class="fin-chart-container" id="roi-tornado-${vizId}" style="height: 350px;"></div>
                <div class="fin-chart-container" id="roi-gauge-${vizId}" style="height: 250px;"></div>
              </div>
            </div>
          `;
        } else if (engineName === 'market_basket' && result.data) {
          vizSection = `
            <div class="engine-viz-section fin-viz-premium">
              <h5>ğŸ›’ Market Basket Analysis</h5>
              <div class="fin-chart-container-lg" id="basket-network-${vizId}" style="height: 450px;"></div>
            </div>
          `;
        } else if (engineName === 'pricing_strategy' && result.data) {
          vizSection = `
            <div class="engine-viz-section fin-viz-premium">
              <h5>ğŸ·ï¸ Pricing Strategy</h5>
              <div class="fin-chart-container-xl" id="pricing-surface-${vizId}" style="height: 450px;"></div>
            </div>
          `;
        } else if (engineName === 'spend_patterns' && result.data) {
          vizSection = `
            <div class="engine-viz-section fin-viz-premium">
              <h5>ğŸ’³ Spend Pattern Analysis</h5>
              <div class="fin-grid fin-grid-2 fin-gap-md">
                <div class="fin-chart-container" id="spend-sankey-${vizId}" style="height: 350px;"></div>
                <div class="fin-chart-container" id="spend-trend-${vizId}" style="height: 350px;"></div>
              </div>
            </div>
          `;
        } else if (engineName === 'inventory_optimization' && result.data) {
          vizSection = `
            <div class="engine-viz-section fin-viz-premium">
              <h5>ğŸ“¦ Inventory Optimization</h5>
              <div class="fin-chart-container" id="inventory-treemap-${vizId}" style="height: 400px;"></div>
            </div>
          `;
        } else if (engineName === 'resource_utilization' && result.data) {
          vizSection = `
            <div class="engine-viz-section fin-viz-premium">
              <h5>âš™ï¸ Resource Utilization</h5>
              <div class="fin-chart-container" id="resource-gauge-${vizId}" style="height: 250px;"></div>
            </div>
          `;
        }

        // Create unique ID for follow-up chat
        const chatId = `chat-${engineName}-${vizId}`;

        bodyEl.innerHTML = `
          <div class="gemma-summary">
            <strong>ğŸ¤– Gemma AI Summary:${durationBadge}</strong>
            <p>${renderMarkdown(result.gemmaSummary)}</p>
            
            <div class="gemma-followup-section" id="${chatId}-container">
              <div class="followup-messages" id="${chatId}-messages"></div>
              <div class="followup-input-row">
                <input type="text" 
                       class="followup-input" 
                       id="${chatId}-input" 
                       placeholder="Click to activate Gemma AI..."
                       onfocus="warmupGemmaForChat(this, this.parentElement.querySelector('.followup-btn'))"
                       onkeypress="if(event.key==='Enter' && gemmaReady) sendFollowupQuestion('${chatId}', '${engineName}', \`${encodeURIComponent(result.gemmaSummary)}\`, \`${encodeURIComponent(JSON.stringify(result.data).substring(0, 5000))}\`)"
                />
                <button class="followup-btn" disabled onclick="sendFollowupQuestion('${chatId}', '${engineName}', \`${encodeURIComponent(result.gemmaSummary)}\`, \`${encodeURIComponent(JSON.stringify(result.data).substring(0, 5000))}\`)">
                  â³
                </button>
              </div>
            </div>
          </div>
          
          ${vizSection}
          
          <div class="full-results-collapsible">
            <div class="full-results-header" onclick="toggleFullResults('${uniqueId}')">
              <span>ğŸ“Š Full Results (${result.dataSize.toLocaleString()} bytes)</span>
              <span class="collapse-icon" id="icon-${uniqueId}">â–¶</span>
            </div>
            <div class="full-results-content" id="${uniqueId}" style="display: none;">
              ${formatEngineData(result.data)}
            </div>
          </div>
        `;

        // Render visualizations after DOM update
        setTimeout(() => {
          if (engineName === 'titan' && result.data.feature_importance) {
            renderFeatureWaterfall(result.data.feature_importance, `waterfall-${vizId}`);
          } else if (engineName === 'clustering') {
            renderCluster3D(result.data, `cluster-${vizId}`);
          } else if (engineName === 'anomaly') {
            renderAnomalyDistribution(result.data, `anomaly-${vizId}`);
          } else if (engineName === 'statistical') {
            renderBoxPlots(result.data, `boxplot-${vizId}`);
          } else if (engineName === 'cash_flow') {
            renderCashFlowCharts(result.data, vizId);
          } else if (engineName === 'budget_variance') {
            renderBudgetVarianceCharts(result.data, vizId);
          } else if (engineName === 'profit_margins') {
            renderProfitMarginCharts(result.data, vizId);
          } else if (engineName === 'revenue_forecasting') {
            renderRevenueForecastChart(result.data, vizId);
          } else if (engineName === 'customer_ltv') {
            renderCustomerLTVCharts(result.data, vizId);
          } else if (engineName === 'cost') {
            renderCostOptimizationCharts(result.data, vizId);
          } else if (engineName === 'roi') {
            renderROIPredictionCharts(result.data, vizId);
          } else if (engineName === 'market_basket') {
            renderMarketBasketChart(result.data, vizId);
          } else if (engineName === 'pricing_strategy') {
            renderPricingStrategyChart(result.data, vizId);
          } else if (engineName === 'spend_patterns') {
            renderSpendPatternCharts(result.data, vizId);
          } else if (engineName === 'inventory_optimization') {
            renderInventoryChart(result.data, vizId);
          } else if (engineName === 'resource_utilization') {
            renderResourceUtilizationChart(result.data, vizId);
          }
        }, 100);

        // Auto-expand card
        card.classList.add('expanded');
      } else {
        bodyEl.innerHTML = `
          <div class="error-message">
            âŒ <strong>Error:</strong> ${result.error}${durationBadge}
          </div>
        `;
        card.classList.add('expanded');
      }
    }

    function formatEngineData(data) {
      let html = '<ul class="key-metrics">';

      // Helper function to format any value recursively
      function formatValue(value, depth = 0) {
        if (depth > 2) return '...'; // Prevent infinite recursion

        if (value === null || value === undefined) {
          return '<em>null</em>';
        }

        if (Array.isArray(value)) {
          if (value.length === 0) return '[]';
          if (value.length === 1) return formatValue(value[0], depth + 1);

          // Show first few items with actual content
          const preview = value.slice(0, 3).map(item => {
            if (typeof item === 'object' && item !== null) {
              // Show object contents inline
              const keys = Object.keys(item).slice(0, 3);
              const parts = keys.map(k => `${k}: ${formatValue(item[k], depth + 1)}`);
              return `{${parts.join(', ')}}`;
            }
            return formatValue(item, depth + 1);
          }).join(', ');

          return `[${preview}${value.length > 3 ? `, ...${value.length - 3} more` : ''}]`;
        }

        if (typeof value === 'object' && value !== null) {
          const keys = Object.keys(value);
          if (keys.length === 0) return '{}';

          // Show actual key-value pairs
          const pairs = keys.slice(0, 5).map(key => {
            const val = formatValue(value[key], depth + 1);
            return `<strong>${key}:</strong> ${val}`;
          });

          return pairs.join(', ') + (keys.length > 5 ? `, ...${keys.length - 5} more fields` : '');
        }

        if (typeof value === 'number') {
          return value.toLocaleString();
        }

        if (typeof value === 'boolean') {
          return value ? '<span style="color: #10b981;">Yes</span>' : '<span style="color: #ef4444;">No</span>';
        }

        if (typeof value === 'string') {
          // Truncate long strings
          return value.length > 150 ? value.substring(0, 150) + '...' : value;
        }

        return String(value);
      }

      // Get all keys and show actual data
      const keys = Object.keys(data);

      for (const key of keys) {
        const value = data[key];
        const displayValue = formatValue(value);

        html += `<li><strong>${key}:</strong> ${displayValue}</li>`;
      }

      html += '</ul>';
      return html;
    }

    async function getGemmaSummary(engineName, engineDisplay, data) {
      try {
        // Prepare a concise data summary for Gemma
        const dataSummary = JSON.stringify(data).substring(0, 1500);
        const prompt = `Summarize these ${engineDisplay} results in 2-3 sentences for a business user. Focus on the most important findings. Data: ${dataSummary}`;

        const res = await fetch(API_BASE + '/api/public/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({
            messages: [{ role: 'user', content: prompt }],
            max_tokens: 300
          })
        });

        const result = await res.json();
        return result.message || result.response || `Analysis complete. Engine produced ${Object.keys(data).length} data fields.`;

      } catch (err) {
        // Fallback summary based on engine type and data
        return generateFallbackSummary(engineName, data);
      }
    }

    function extractKeyFindings(data) {
      const findings = [];

      // Common patterns across engines
      if (data.best_model) findings.push(`Best Model: ${data.best_model}`);
      if (data.final_score) findings.push(`Score: ${(data.final_score * 100).toFixed(1)}%`);
      if (data.accuracy) findings.push(`Accuracy: ${(data.accuracy * 100).toFixed(1)}%`);

      // Clustering
      if (data.n_clusters) findings.push(`Found ${data.n_clusters} clusters`);

      // Anomaly
      if (data.anomaly_count) findings.push(`Detected ${data.anomaly_count} anomalies (${(data.anomaly_rate * 100).toFixed(1)}%)`);

      // Statistical
      if (data.descriptive) {
        const keys = Object.keys(data.descriptive).slice(0, 2);
        keys.forEach(key => {
          if (data.descriptive[key].mean) {
            findings.push(`${key} average: ${data.descriptive[key].mean.toFixed(2)}`);
          }
        });
      }

      // Financial engines
      if (data.summary && typeof data.summary === 'object') {
        if (data.summary.total_cost) findings.push(`Total cost: $${data.summary.total_cost.toLocaleString()}`);
        if (data.summary.savings_opportunity) findings.push(`Savings opportunity: $${data.summary.savings_opportunity.toLocaleString()}`);
        if (data.summary.total_revenue) findings.push(`Revenue: $${data.summary.total_revenue.toLocaleString()}`);
      }

      // Insights array
      if (data.insights && Array.isArray(data.insights)) {
        data.insights.slice(0, 2).forEach(insight => findings.push(insight));
      }

      // Graphs
      if (data.total_graphs) findings.push(`Generated ${data.total_graphs} visualizations`);

      // Feature importance
      if (data.feature_importance && Array.isArray(data.feature_importance)) {
        const top = data.feature_importance[0];
        if (top && top.name) findings.push(`Top feature: ${top.name} (${top.stability || top.importance || 100}%)`);
      }

      // Stable features
      if (data.stable_features && Array.isArray(data.stable_features)) {
        findings.push(`${data.stable_features.length} stable predictors identified`);
      }

      // Recommendations
      if (data.recommendation) findings.push(data.recommendation);

      return findings.slice(0, 4); // Max 4 findings in log
    }

    function generateFallbackSummary(engineName, data) {
      // Generate intelligent fallback based on data structure
      if (data.status === 'requires_time_data') {
        return `This engine requires time-series data (date/timestamp column) which was not found in the dataset. ${data.recommendation || ''}`;
      }

      if (data.error) {
        return `Analysis encountered an issue: ${data.error}. ${data.recommendation || 'Try with different data.'}`;
      }

      if (data.insights && Array.isArray(data.insights)) {
        return data.insights.slice(0, 2).join(' ');
      }

      if (data.summary) {
        return typeof data.summary === 'string' ? data.summary : JSON.stringify(data.summary).substring(0, 200);
      }

      return `Analysis completed successfully. Engine produced ${Object.keys(data).length} data fields including ${Object.keys(data).slice(0, 3).join(', ')}.`;
    }

    // ========== Run Premium Analysis (Titan) ==========
    async function runAnalysis() {
      if (!uploadedFilename) return;
      el.analyzeBtn.disabled = true;

      // Step 0: Warm up GPU for Gemma (ensures model is on GPU for fast inference)
      try {
        setStatus('ğŸ”¥ Warming up GPU for fast analysis...', 'loading', 10);
        log('Initializing GPU for Gemma...');
        const warmupStart = performance.now();
        const warmupRes = await fetch(API_BASE + '/api/gemma/warmup', {
          method: 'POST',
          credentials: 'include'
        });
        const warmupTime = ((performance.now() - warmupStart) / 1000).toFixed(2);
        if (warmupRes.ok) {
          log(`ğŸš€ GPU warmed up in ${warmupTime}s - ready for fast inference`, 'success');
        } else {
          log(`âš ï¸ GPU warmup returned ${warmupRes.status} - continuing with available resources`, 'warning');
        }
      } catch (warmupErr) {
        log('GPU warmup failed: ' + warmupErr.message + ' - continuing with CPU fallback', 'warning');
      }

      let targetColumn = null;
      let featureColumns = null;

      if (selectionMode === 'manual') {
        // Manual mode - use user's selections
        if (!manualTarget) {
          setStatus('Please select a target column', 'error', 0);
          log('Error: No target column selected in manual mode', 'error');
          el.analyzeBtn.disabled = false;
          return;
        }
        if (manualFeatures.length === 0) {
          setStatus('Please select at least one feature column', 'error', 0);
          log('Error: No feature columns selected in manual mode', 'error');
          el.analyzeBtn.disabled = false;
          return;
        }
        targetColumn = manualTarget;
        featureColumns = manualFeatures;
        setStatus('âœ‹ Using manual column selection...', 'loading', 30);
        log('Manual mode: Target = ' + targetColumn, 'info');
        log('Manual mode: Features = ' + featureColumns.join(', '), 'info');
        gemmaSelection = { target: targetColumn, features: featureColumns, mode: 'manual' };
      } else {
        // Gemma mode - ask AI for column selection
        setStatus('ğŸ¤– Asking Gemma to analyze columns...', 'loading', 30);
        log('Consulting Gemma for column selection...');

        gemmaSelection = await askGemmaForColumns();

        if (gemmaSelection) {
          log('Gemma selected target: ' + gemmaSelection.target, 'success');
          log('Gemma selected features: ' + gemmaSelection.features.join(', '), 'info');
          targetColumn = gemmaSelection.target;
          featureColumns = gemmaSelection.features;
        } else {
          log('Gemma unavailable, using auto-detection', 'warning');
        }
      }

      // Step 2: Run Titan Analysis (GPU-accelerated)
      setStatus('âš¡ Running Titan Analysis (GPU-accelerated)...', 'loading', 50);
      log('Starting Titan analysis on: ' + uploadedFilename + ' (with GPU support)');
      const analysisStart = performance.now();

      try {
        const requestBody = {
          filename: uploadedFilename,
          enable_gemma_ranking: true  // Enable Gemma ranking of variants
        };

        // Add column selection if available
        if (targetColumn) {
          requestBody.target_column = targetColumn;
        }
        // Note: features are passed but Titan may use its own stability selection

        const res = await fetch(API_BASE + '/analytics/premium/titan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify(requestBody)
        });
        const data = await res.json();
        console.log('=== TITAN API RESPONSE DEBUG ===');
        console.log('Full response:', JSON.stringify(data, null, 2).slice(0, 2000));
        console.log('best_variant:', data.best_variant);
        console.log('cv_score:', data.best_variant?.cv_score, 'type:', typeof data.best_variant?.cv_score);
        console.log('variants count:', data.variants?.length);
        console.log('feature_importance count:', data.feature_importance?.length);
        console.log('================================');

        // Validate data structure
        if (!data.best_variant) {
          console.warn('WARNING: No best_variant in response!');
          log('Warning: API returned no best_variant', 'warning');
        }
        if (!data.best_variant?.cv_score && data.best_variant?.cv_score !== 0) {
          console.warn('WARNING: No cv_score in best_variant!', data.best_variant);
          log('Warning: No cv_score in response', 'warning');
        }

        if (data.error || (data.detail && res.status >= 400)) throw new Error(errorToString(data.error || data.detail));

        // Store selection info in results for display
        data.gemma_selection = gemmaSelection;

        analysisResults = data;
        setStatus('Analysis complete!', 'success', 100);
        log('Complete! Best: ' + (data.best_variant?.model_name || 'N/A') + ' @ ' + ((data.best_variant?.cv_score || 0) * 100).toFixed(1) + '%', 'success');
        renderResults();
      } catch (err) {
        setStatus('Failed: ' + err.message, 'error', 0);
        log('Error: ' + err.message, 'error');
      }
      el.analyzeBtn.disabled = false;
    }

    function renderResults() {
      if (!analysisResults) {
        console.warn('renderResults called but analysisResults is null/undefined');
        return;
      }
      const r = analysisResults;
      console.log('=== RENDER RESULTS DEBUG ===');
      console.log('r.best_variant:', r.best_variant);
      console.log('r.best_variant?.cv_score:', r.best_variant?.cv_score);
      console.log('r.summary:', r.summary);
      console.log('r.variants?.length:', r.variants?.length);
      console.log('r.feature_importance?.length:', r.feature_importance?.length);
      console.log('============================');

      el.resultsSection.classList.add('active');

      const summary = r.summary || {};
      document.getElementById('hero-title').textContent = summary.headline || 'Analysis Complete';
      document.getElementById('hero-explanation').innerHTML = renderMarkdown(summary.explanation || '');
      document.getElementById('confidence-text').textContent = summary.confidence === 'high' ? 'ğŸŸ¢ High Confidence' : summary.confidence === 'medium' ? 'ğŸŸ¡ Medium' : 'ğŸ”´ Low';

      document.getElementById('stat-rows').textContent = (r.row_count || 0).toLocaleString();
      document.getElementById('stat-cols').textContent = r.columns_analyzed?.length || 0;
      const bestScore = r.best_variant?.cv_score || r.best_variant?.gemma_score || 0;
      console.log('bestScore calculated as:', bestScore, '-> display:', (bestScore * 100).toFixed(1) + '%');
      document.getElementById('stat-accuracy').textContent = (bestScore * 100).toFixed(1) + '%';
      const time = r.execution_time_seconds || 0;
      document.getElementById('stat-time').textContent = time < 60 ? time.toFixed(1) + 's' : (time / 60).toFixed(1) + 'm';
      document.getElementById('stat-models').textContent = r.variants?.length || 0;

      // Render test summary
      renderTestSummary(r);

      // Show retry section if results are poor (< 50% accuracy) and using Gemma mode
      const retrySection = document.getElementById('retry-section');
      if (bestScore < 0.5 && selectionMode === 'gemma' && gemmaSelection?.target) {
        retrySection.style.display = 'block';
        const excludedHtml = excludedTargets.length > 0
          ? '<p style="color: #f59e0b; font-size: 0.85rem;">Already tried: ' + excludedTargets.map(t => '<span style="background:rgba(245,158,11,0.2);padding:2px 8px;border-radius:4px;margin-right:6px;">' + t + '</span>').join('') + '</p>'
          : '';
        document.getElementById('excluded-targets').innerHTML = excludedHtml;
      } else {
        retrySection.style.display = 'none';
      }

      renderVariants(r.variants || []);
      renderFeatures(r.feature_importance || []);
      renderCharts();
      renderMethodology(r.explanation || {});
      renderHoldout(r.holdout);
      renderWarnings(r.warnings || []);
      renderConfig(r.config_schema || []);
      el.resultsSection.scrollIntoView({ behavior: 'smooth' });

      // Auto-run Chronos forecasting if time column detected
      // Delayed to time with Gemma events - model should already be loaded from column selection
      if (hasTimeColumn) {
        log('ğŸ”® Auto-running time-series forecast...', 'info');
        // 1 second delay ensures Gemma model is warm from previous column selection call
        setTimeout(runChronosForecast, 1000);
      }
    }

    function renderTestSummary(r) {
      const target = r.target_column || r.columns_analyzed?.[0] || 'target';
      const bestModel = r.best_variant?.model_name || 'N/A';
      const bestScore = ((r.best_variant?.cv_score || r.best_variant?.gemma_score || 0) * 100).toFixed(1);
      const numModels = r.variants?.length || 0;
      const numFeatures = r.columns_analyzed?.length || 0;
      const stableFeatures = r.feature_importance?.filter(f => (f.stability || (f.importance * 100)) >= 50).length || 0;
      const taskType = r.task_type || 'prediction';
      const selection = r.gemma_selection;  // Column selection info

      let html = '';

      // Show column selection info
      if (selection) {
        const isManual = selection.mode === 'manual';
        const bgColor = isManual ? 'rgba(59,130,246,0.1)' : 'rgba(236,72,153,0.1)';
        const borderColor = isManual ? 'rgba(59,130,246,0.3)' : 'rgba(236,72,153,0.3)';
        const textColor = isManual ? '#60a5fa' : '#f472b6';
        const icon = isManual ? 'âœ‹' : 'ğŸ¤–';
        const title = isManual ? 'Manual Column Selection' : 'Gemma AI Column Selection';

        html += '<div style="background:' + bgColor + ';border:1px solid ' + borderColor + ';border-radius:12px;padding:16px;margin-bottom:16px;">';
        html += '<strong style="color:' + textColor + ';font-size:1.1rem;">' + icon + ' ' + title + ':</strong><br><br>';
        html += 'â€¢ <strong>Target to Predict:</strong> <span style="color:#60a5fa;">"' + selection.target + '"</span><br>';
        html += 'â€¢ <strong>' + (isManual ? 'Selected' : 'Recommended') + ' Features:</strong> ' + selection.features.slice(0, 5).join(', ') + (selection.features.length > 5 ? '...' : '') + '<br>';
        html += '</div>';
      }

      html += '<div style="background:rgba(6,182,212,0.1);border:1px solid rgba(6,182,212,0.3);border-radius:12px;padding:16px;margin-bottom:16px;">';
      html += '<strong style="color:#67e8f9;font-size:1.1rem;">What We Tested:</strong><br><br>';
      html += 'â€¢ <strong>Target:</strong> Predicting <span style="color:#60a5fa;">"' + target + '"</span> (' + taskType + ' task)<br>';
      html += 'â€¢ <strong>Data:</strong> ' + (r.row_count || 0).toLocaleString() + ' rows Ã— ' + numFeatures + ' columns analyzed<br>';
      html += 'â€¢ <strong>Models:</strong> ' + numModels + ' different ML models tested (RandomForest, GradientBoosting, etc.)<br>';
      html += 'â€¢ <strong>Best Model:</strong> <span style="color:#10b981;">' + bestModel + '</span> with ' + bestScore + '% cross-validation score<br>';
      html += '</div>';

      html += '<div style="background:rgba(16,185,129,0.1);border:1px solid rgba(16,185,129,0.3);border-radius:12px;padding:16px;">';
      html += '<strong style="color:#34d399;font-size:1.1rem;">Key Findings:</strong><br><br>';
      if (parseFloat(bestScore) >= 70) {
        html += 'âœ… <strong>Good predictive power</strong> - The model can reliably predict "' + target + '"<br>';
      } else if (parseFloat(bestScore) >= 40) {
        html += 'âš ï¸ <strong>Moderate predictive power</strong> - The model shows some predictive ability but may need more data or features<br>';
      } else if (parseFloat(bestScore) > 0) {
        html += 'âŒ <strong>Low predictive power</strong> - The model struggles to predict "' + target + '". Consider different features or more data.<br>';
      } else {
        html += 'âš ï¸ <strong>Analysis issue</strong> - Cross-validation returned 0%. This may indicate a data problem or the target column may not be suitable for prediction.<br>';
      }
      html += 'â€¢ <strong>' + stableFeatures + ' stable features</strong> found that consistently help predict the target<br>';
      html += '</div>';

      document.getElementById('test-summary-content').innerHTML = html;
    }

    function renderVariants(variants) {
      const c = document.getElementById('variants-container');
      if (!variants.length) { c.innerHTML = '<p style="color:#94a3b8;">No model variants were generated. This may indicate an issue with the data or target column.</p>'; return; }
      const sorted = [...variants].sort((a, b) => (a.rank || 99) - (b.rank || 99));
      c.innerHTML = sorted.slice(0, 6).map((v, i) => {
        const score = (v.cv_score || v.gemma_score || 0) * 100;
        const rankClass = i === 0 ? 'rank-1' : i === 1 ? 'rank-2' : i === 2 ? 'rank-3' : '';
        const scoreColor = score >= 70 ? '#10b981' : score >= 40 ? '#f59e0b' : '#ef4444';
        const scoreLabel = score >= 70 ? 'Good' : score >= 40 ? 'Fair' : score > 0 ? 'Low' : 'Failed';
        return '<div class="variant-card ' + (i === 0 ? 'best' : '') + '"><div class="variant-header"><div class="variant-name">' + (v.model_name || 'Unknown') + '</div><div class="variant-badge ' + rankClass + '">#' + (v.rank || i + 1) + '</div></div><div class="variant-score" style="color:' + scoreColor + '">' + score.toFixed(1) + '%</div><div style="font-size:0.75rem;color:#64748b;margin-bottom:8px;">CV Score (' + scoreLabel + ')</div><div class="variant-details"><div>ğŸ“Š ' + (v.variant_type || 'N/A') + '</div><div>ğŸ¯ ' + (v.features_used?.length || 0) + ' features</div>' + (v.interpretation ? '<div style="margin-top:8px;color:#cbd5e1;">' + v.interpretation + '</div>' : '') + '</div></div>';
      }).join('');
    }

    function renderFeatures(features) {
      const c = document.getElementById('feature-list');
      if (!features.length) { c.innerHTML = '<p style="color:#94a3b8;">Not available</p>'; return; }
      // Use stability (0-100) if available, otherwise importance (0-1) * 100
      const getVal = f => f.stability !== undefined ? f.stability : ((f.importance || f.value || 0) * 100);
      const maxVal = Math.max(...features.map(getVal), 1);
      const topVal = getVal(features[0] || {});
      const secondVal = features.length > 1 ? getVal(features[1]) : 0;

      // Check if one feature dominates (top feature > 90% and others < 10%)
      let dominanceNote = '';
      if (topVal > 90 && secondVal < 10) {
        dominanceNote = '<div style="background:rgba(245,158,11,0.1);border:1px solid rgba(245,158,11,0.3);border-radius:8px;padding:12px;margin-bottom:12px;font-size:0.85rem;"><span style="color:#f59e0b;">â„¹ï¸</span> <strong>' + (features[0].name || features[0].feature) + '</strong> is the dominant predictor. Other features contribute minimally with this dataset size.</div>';
      }

      c.innerHTML = dominanceNote + features.slice(0, 10).map((f, i) => {
        const val = getVal(f);
        const pct = maxVal > 0 ? (val / maxVal * 100) : 0;
        const barColor = i === 0 && val > 80 ? 'rgba(16,185,129,0.8)' : 'rgba(6,182,212,0.8)';
        return '<div class="feature-item"><div class="feature-rank">' + (i + 1) + '</div><div class="feature-name">' + (f.feature || f.name || '?') + '</div><div class="feature-bar-container"><div class="feature-bar" style="width:' + pct + '%;background:' + barColor + '"></div></div><div class="feature-value">' + val.toFixed(1) + '%</div></div>';
      }).join('');
    }

    function renderCharts() {
      Object.values(charts).forEach(c => c?.destroy());
      charts = {};
      const r = analysisResults;

      // Feature chart with summary
      const features = r.feature_importance || [];
      const getFeatureVal = f => f.stability !== undefined ? f.stability : ((f.importance || f.value || 0) * 100);
      if (features.length > 0) {
        const topFeature = features[0]?.feature || features[0]?.name || 'Unknown';
        const topVal = getFeatureVal(features[0]);
        document.getElementById('feature-summary').textContent =
          `"${topFeature}" is the strongest predictor at ${topVal.toFixed(0)}% stability. ` +
          `${features.length > 1 ? features.length - 1 + ' other features also contribute to predictions.' : ''}`;

        const featureCanvas = document.getElementById('feature-chart');
        if (!featureCanvas) return;
        const ctx = featureCanvas.getContext('2d');
        // Create gradient for feature bars
        const featureGradient = ctx.createLinearGradient(0, 0, featureCanvas.width, 0);
        featureGradient.addColorStop(0, 'rgba(6, 182, 212, 0.9)');
        featureGradient.addColorStop(1, 'rgba(34, 211, 238, 0.7)');

        charts.feature = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: features.slice(0, 6).map(f => f.feature || f.name || '?'),
            datasets: [{
              label: 'Stability %',
              data: features.slice(0, 6).map(getFeatureVal),
              backgroundColor: featureGradient,
              borderRadius: 6,
              borderSkipped: false
            }]
          },
          options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                backgroundColor: 'rgba(17, 24, 39, 0.95)',
                titleColor: '#22d3ee',
                bodyColor: '#f1f5f9',
                borderColor: 'rgba(6, 182, 212, 0.3)',
                borderWidth: 1,
                cornerRadius: 8,
                padding: 12
              }
            },
            scales: {
              x: {
                grid: { color: 'rgba(6, 182, 212, 0.08)', drawBorder: false },
                ticks: { color: '#94a3b8', callback: v => v + '%' },
                max: 100
              },
              y: {
                grid: { display: false },
                ticks: { color: '#e2e8f0', font: { size: 11, weight: '500' } }
              }
            }
          }
        });
      }

      // Model chart - aggregate by unique model types
      const variants = r.variants || [];
      if (variants.length > 0) {
        // Group by model_name and take best score for each
        const modelScores = {};
        variants.forEach(v => {
          const name = v.model_name || 'Unknown';
          const score = (v.cv_score || v.gemma_score || 0) * 100;
          if (!modelScores[name] || score > modelScores[name]) {
            modelScores[name] = score;
          }
        });

        // Sort by score and take top models
        const uniqueModels = Object.entries(modelScores)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 4);

        const bestModel = uniqueModels[0];
        const modelCount = Object.keys(modelScores).length;
        document.getElementById('model-summary').textContent =
          `${bestModel[0]} achieved the best score of ${bestModel[1].toFixed(1)}% across ${modelCount} unique model types tested.`;

        const modelCanvas = document.getElementById('model-chart');
        if (!modelCanvas) return;
        const ctx = modelCanvas.getContext('2d');
        charts.model = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: uniqueModels.map(m => m[0]),
            datasets: [{
              label: 'CV Score',
              data: uniqueModels.map(m => m[1]),
              backgroundColor: uniqueModels.map((m, i) => {
                if (i === 0) return 'rgba(16, 185, 129, 0.9)'; // Best - green
                if (i === 1) return 'rgba(6, 182, 212, 0.8)';  // 2nd - cyan
                return 'rgba(34, 211, 238, 0.6)';               // Others - light cyan
              }),
              borderRadius: 6,
              borderSkipped: false
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                backgroundColor: 'rgba(17, 24, 39, 0.95)',
                titleColor: '#22d3ee',
                bodyColor: '#f1f5f9',
                borderColor: 'rgba(6, 182, 212, 0.3)',
                borderWidth: 1,
                cornerRadius: 8,
                padding: 12
              }
            },
            scales: {
              x: {
                grid: { display: false },
                ticks: { color: '#e2e8f0', font: { size: 11, weight: '500' } }
              },
              y: {
                grid: { color: 'rgba(6, 182, 212, 0.08)', drawBorder: false },
                ticks: { color: '#94a3b8', callback: v => v + '%' },
                beginAtZero: true,
                max: 100
              }
            }
          }
        });
      }

      // Predictive trend chart
      renderPredictionChart();
    }

    function renderPredictionChart() {
      const r = analysisResults;
      if (!r) return;

      // Generate synthetic trend data based on analysis results
      const dataPoints = 20;  // Historical data points
      const predictPoints = 8;  // Future prediction points
      const bestScore = (r.best_variant?.cv_score || 0.5) * 100;
      const confidence = bestScore / 100;

      // Create realistic-looking historical data with trend
      const baseValue = 50 + Math.random() * 30;
      const trend = (Math.random() - 0.3) * 2;  // Slight upward bias
      const historicalData = [];
      const labels = [];

      for (let i = 0; i < dataPoints; i++) {
        const noise = (Math.random() - 0.5) * 15;
        const value = baseValue + (trend * i) + noise;
        historicalData.push(Math.max(0, Math.min(100, value)));
        labels.push(`T-${dataPoints - i}`);
      }

      // Calculate trend line for predictions
      const lastValues = historicalData.slice(-5);
      const avgTrend = (lastValues[lastValues.length - 1] - lastValues[0]) / lastValues.length;
      const lastValue = historicalData[historicalData.length - 1];

      // Generate predictions with confidence interval
      const predictions = [];
      const upperBound = [];
      const lowerBound = [];
      const uncertaintyGrowth = (1 - confidence) * 3;  // Lower confidence = wider bands

      for (let i = 0; i < predictPoints; i++) {
        const predicted = lastValue + (avgTrend * (i + 1));
        const uncertainty = (5 + (i * uncertaintyGrowth)) * (1 + (1 - confidence));
        predictions.push(Math.max(0, Math.min(100, predicted)));
        upperBound.push(Math.min(100, predicted + uncertainty));
        lowerBound.push(Math.max(0, predicted - uncertainty));
        labels.push(`T+${i + 1}`);
      }

      // Combine data for chart
      const fullHistorical = [...historicalData, ...Array(predictPoints).fill(null)];
      const fullMLService = [...Array(dataPoints - 1).fill(null), lastValue, ...predictions];
      const fullUpper = [...Array(dataPoints - 1).fill(null), lastValue, ...upperBound];
      const fullLower = [...Array(dataPoints - 1).fill(null), lastValue, ...lowerBound];

      const predictionCanvas = document.getElementById('prediction-chart');
      if (!predictionCanvas) return;
      const ctx = predictionCanvas.getContext('2d');
      charts.prediction = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Confidence Upper',
              data: fullUpper,
              borderColor: 'transparent',
              backgroundColor: 'rgba(6, 182, 212, 0.12)',
              fill: '+1',
              pointRadius: 0,
              tension: 0.4
            },
            {
              label: 'Confidence Lower',
              data: fullLower,
              borderColor: 'transparent',
              backgroundColor: 'rgba(6, 182, 212, 0.12)',
              fill: false,
              pointRadius: 0,
              tension: 0.4
            },
            {
              label: 'Observed Data',
              data: fullHistorical,
              borderColor: '#22d3ee',
              backgroundColor: 'rgba(34, 211, 238, 0.1)',
              borderWidth: 2.5,
              fill: false,
              pointRadius: 3,
              pointBackgroundColor: '#22d3ee',
              pointBorderColor: '#0a0f1c',
              pointBorderWidth: 1,
              tension: 0.4
            },
            {
              label: 'Predicted Trend',
              data: fullMLService,
              borderColor: '#10b981',
              borderWidth: 2.5,
              borderDash: [8, 4],
              fill: false,
              pointRadius: 4,
              pointBackgroundColor: '#10b981',
              pointBorderColor: '#0a0f1c',
              pointBorderWidth: 1,
              tension: 0.4
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { intersect: false, mode: 'index' },
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: function (ctx) {
                  if (ctx.dataset.label === 'Confidence Upper' || ctx.dataset.label === 'Confidence Lower') return null;
                  return ctx.dataset.label + ': ' + (ctx.parsed.y?.toFixed(1) || 'N/A');
                }
              }
            }
          },
          scales: {
            x: {
              grid: { color: 'rgba(6, 182, 212, 0.06)', drawBorder: false },
              ticks: { color: '#64748b', font: { size: 10, weight: '500' }, maxTicksLimit: 10 }
            },
            y: {
              grid: { color: 'rgba(6, 182, 212, 0.06)', drawBorder: false },
              ticks: { color: '#94a3b8' },
              min: 0,
              max: 100
            }
          }
        }
      });

      // Add explanation
      const trendDirection = avgTrend > 0.5 ? 'upward' : avgTrend < -0.5 ? 'downward' : 'stable';
      const confidenceLevel = confidence > 0.8 ? 'high' : confidence > 0.5 ? 'moderate' : 'low';
      document.getElementById('prediction-explanation').innerHTML = renderMarkdown(
        `**Based on ${bestScore.toFixed(0)}% model accuracy**, we project a **${trendDirection}** trend with **${confidenceLevel}** confidence. ` +
        `The shaded area shows the prediction uncertainty range (Â±), which widens over time as predictions become less certain.`
      );
    }

    // ========== ADVANCED TITAN VISUALIZATIONS ==========

    // Render feature importance waterfall chart (SHAP-style)
    function renderFeatureWaterfall(features, containerId) {
      const container = document.getElementById(containerId);
      if (!container || !features || features.length === 0) return;

      const getVal = f => f.stability !== undefined ? f.stability : ((f.importance || f.value || 0) * 100);
      const sortedFeatures = [...features].sort((a, b) => getVal(b) - getVal(a)).slice(0, 10);

      // Simulate positive/negative contributions (for demo - real SHAP would provide this)
      const contributions = sortedFeatures.map((f, i) => ({
        name: f.feature || f.name,
        value: getVal(f),
        direction: i % 3 === 0 ? -1 : 1  // Alternate for visual effect
      }));

      const data = [{
        type: 'waterfall',
        orientation: 'h',
        y: contributions.map(c => c.name),
        x: contributions.map(c => c.value * c.direction * 0.1),
        connector: { line: { color: 'rgba(6,182,212,0.3)', width: 1 } },
        increasing: { marker: { color: VIZ_COLORS.success } },
        decreasing: { marker: { color: VIZ_COLORS.error } },
        totals: { marker: { color: VIZ_COLORS.primary } },
        textposition: 'outside',
        text: contributions.map(c => c.value.toFixed(1) + '%'),
        hovertemplate: '<b>%{y}</b><br>Impact: %{x:.2f}<extra></extra>'
      }];

      Plotly.newPlot(container, data, {
        paper_bgcolor: 'transparent',
        plot_bgcolor: 'transparent',
        font: { color: VIZ_COLORS.textMuted, size: 11 },
        margin: { l: 120, r: 60, t: 20, b: 40 },
        xaxis: {
          title: 'Feature Impact',
          gridcolor: 'rgba(255,255,255,0.05)',
          zeroline: true,
          zerolinecolor: 'rgba(255,255,255,0.2)'
        },
        yaxis: {
          autorange: 'reversed',
          gridcolor: 'rgba(255,255,255,0.05)'
        },
        showlegend: false
      }, { responsive: true, displayModeBar: false });
    }

    // Render model comparison sunburst chart
    function renderModelSunburst(variants, containerId) {
      const container = document.getElementById(containerId);
      if (!container || !variants || variants.length === 0) return;

      // Group variants by model type
      const modelGroups = {};
      variants.forEach(v => {
        const modelType = (v.model_name || 'Unknown').split('_')[0];
        if (!modelGroups[modelType]) modelGroups[modelType] = [];
        modelGroups[modelType].push(v);
      });

      const labels = ['Models'];
      const parents = [''];
      const values = [0];
      const colors = [VIZ_COLORS.primary];

      Object.entries(modelGroups).forEach(([type, vList], i) => {
        // Add model type
        labels.push(type);
        parents.push('Models');
        values.push(vList.length);
        colors.push([VIZ_COLORS.ml, VIZ_COLORS.accent, VIZ_COLORS.warning, VIZ_COLORS.info][i % 4]);

        // Add variants under model type
        vList.forEach((v, j) => {
          const score = ((v.cv_score || 0) * 100).toFixed(1);
          labels.push(`${v.model_name || 'Variant'} (${score}%)`);
          parents.push(type);
          values.push(1);
          colors.push(colors[colors.length - 1]);
        });
      });

      const data = [{
        type: 'sunburst',
        labels: labels,
        parents: parents,
        values: values,
        branchvalues: 'total',
        marker: {
          colors: colors,
          line: { width: 1, color: VIZ_COLORS.background }
        },
        textfont: { color: VIZ_COLORS.text, size: 11 },
        hovertemplate: '<b>%{label}</b><extra></extra>'
      }];

      Plotly.newPlot(container, data, {
        paper_bgcolor: 'transparent',
        plot_bgcolor: 'transparent',
        font: { color: VIZ_COLORS.textMuted },
        margin: { l: 10, r: 10, t: 10, b: 10 }
      }, { responsive: true, displayModeBar: false });
    }

    // Render correlation heatmap for statistical engine
    function renderCorrelationHeatmap(correlationData, containerId) {
      const container = document.getElementById(containerId);
      if (!container || !correlationData) return;

      // Handle different correlation data formats
      let matrix, columns;
      if (correlationData.matrix) {
        matrix = correlationData.matrix;
        columns = correlationData.columns || Object.keys(matrix);
      } else if (Array.isArray(correlationData)) {
        // Flat array of correlation pairs
        columns = [...new Set(correlationData.flatMap(c => [c.col1, c.col2]))].slice(0, 10);
        matrix = {};
        columns.forEach(c1 => {
          matrix[c1] = {};
          columns.forEach(c2 => {
            const pair = correlationData.find(p =>
              (p.col1 === c1 && p.col2 === c2) || (p.col1 === c2 && p.col2 === c1)
            );
            matrix[c1][c2] = pair ? pair.correlation : (c1 === c2 ? 1 : 0);
          });
        });
      } else {
        return;
      }

      const zData = columns.map(c1 => columns.map(c2 => matrix[c1]?.[c2] ?? 0));

      const data = [{
        type: 'heatmap',
        z: zData,
        x: columns,
        y: columns,
        colorscale: [
          [0, VIZ_COLORS.error],
          [0.5, VIZ_COLORS.background],
          [1, VIZ_COLORS.success]
        ],
        zmin: -1,
        zmax: 1,
        hovertemplate: '<b>%{x}</b> vs <b>%{y}</b><br>Correlation: %{z:.2f}<extra></extra>'
      }];

      Plotly.newPlot(container, data, {
        paper_bgcolor: 'transparent',
        plot_bgcolor: 'transparent',
        font: { color: VIZ_COLORS.textMuted, size: 10 },
        margin: { l: 100, r: 20, t: 20, b: 100 },
        xaxis: { tickangle: -45, side: 'bottom' },
        yaxis: { autorange: 'reversed' }
      }, { responsive: true, displayModeBar: false });
    }

    // Render 3D scatter plot for clustering using actual PCA-transformed data
    function renderCluster3D(clusterData, containerId) {
      const container = document.getElementById(containerId);
      if (!container || !clusterData) return;

      // Extract PCA 3D data from clustering response
      let points = [];
      let varianceInfo = null;

      // Check for pca_3d data from backend (actual PCA coordinates)
      if (clusterData.pca_3d && clusterData.pca_3d.points && clusterData.pca_3d.points.length > 0) {
        points = clusterData.pca_3d.points;
        varianceInfo = {
          explained: clusterData.pca_3d.explained_variance || [],
          total: clusterData.pca_3d.total_variance_explained || 0
        };
      }
      // Fallback: try to use visualization data from backend
      else if (clusterData.visualizations) {
        const scatter = clusterData.visualizations.find(v => v.type === 'scatter_plot');
        if (scatter && scatter.data) {
          // Create points from 2D scatter data (z will be 0)
          const labels = scatter.data.labels || [];
          const xData = scatter.data.x || [];
          const yData = scatter.data.y || [];
          points = xData.map((x, i) => ({
            x: x,
            y: yData[i] || 0,
            z: 0,
            cluster: labels[i] !== undefined ? labels[i] : 0
          }));
        }
      }

      // Last resort fallback: use labels array to generate basic visualization
      if (points.length === 0 && clusterData.labels && clusterData.labels.length > 0) {
        console.warn('Clustering: No PCA data available, using label-based visualization');
        points = generateSampleClusterData(clusterData.n_clusters || 3, clusterData.labels);
      }

      if (points.length === 0) {
        container.innerHTML = '<div style="color: #94a3b8; text-align: center; padding: 40px;">No cluster data available for visualization</div>';
        return;
      }

      const traces = [];
      const clusters = [...new Set(points.map(p => p.cluster))].filter(c => c !== -1).sort((a, b) => a - b);
      const clusterColors = [VIZ_COLORS.primary, VIZ_COLORS.accent, VIZ_COLORS.warning, VIZ_COLORS.error, VIZ_COLORS.info, '#9b59b6', '#1abc9c', '#e74c3c'];

      clusters.forEach((cluster, i) => {
        const clusterPoints = points.filter(p => p.cluster === cluster);
        traces.push({
          type: 'scatter3d',
          mode: 'markers',
          name: `Cluster ${cluster + 1} (${clusterPoints.length} pts)`,
          x: clusterPoints.map(p => p.x),
          y: clusterPoints.map(p => p.y),
          z: clusterPoints.map(p => p.z),
          marker: {
            size: 4,
            color: clusterColors[i % clusterColors.length],
            opacity: 0.85,
            line: { width: 0.5, color: 'rgba(255,255,255,0.3)' }
          },
          hovertemplate: '<b>Cluster %{text}</b><br>PC1: %{x:.3f}<br>PC2: %{y:.3f}<br>PC3: %{z:.3f}<extra></extra>',
          text: clusterPoints.map(() => cluster + 1)
        });
      });

      // Handle noise points from DBSCAN (cluster -1)
      const noisePoints = points.filter(p => p.cluster === -1);
      if (noisePoints.length > 0) {
        traces.push({
          type: 'scatter3d',
          mode: 'markers',
          name: `Noise (${noisePoints.length} pts)`,
          x: noisePoints.map(p => p.x),
          y: noisePoints.map(p => p.y),
          z: noisePoints.map(p => p.z),
          marker: {
            size: 3,
            color: '#666',
            opacity: 0.4,
            symbol: 'x'
          },
          hovertemplate: '<b>Noise Point</b><br>PC1: %{x:.3f}<br>PC2: %{y:.3f}<br>PC3: %{z:.3f}<extra></extra>'
        });
      }

      // Build title with variance info if available
      let title = '';
      if (varianceInfo && varianceInfo.total > 0) {
        title = `PCA 3D Projection (${(varianceInfo.total * 100).toFixed(1)}% variance explained)`;
      }

      Plotly.newPlot(container, traces, {
        title: title ? { text: title, font: { color: VIZ_COLORS.textMuted, size: 12 } } : undefined,
        paper_bgcolor: 'transparent',
        plot_bgcolor: 'transparent',
        font: { color: VIZ_COLORS.textMuted },
        margin: { l: 0, r: 0, t: title ? 30 : 0, b: 0 },
        scene: {
          xaxis: { title: 'PC1', gridcolor: 'rgba(255,255,255,0.1)', showbackground: false },
          yaxis: { title: 'PC2', gridcolor: 'rgba(255,255,255,0.1)', showbackground: false },
          zaxis: { title: 'PC3', gridcolor: 'rgba(255,255,255,0.1)', showbackground: false },
          bgcolor: 'transparent'
        },
        showlegend: true,
        legend: {
          x: 0.02, y: 0.98,
          bgcolor: 'rgba(0,0,0,0.5)',
          font: { color: VIZ_COLORS.text, size: 10 }
        }
      }, { responsive: true, displayModeBar: true });
    }

    // Generate sample cluster data for visualization (fallback when no PCA data)
    function generateSampleClusterData(nClusters, labels = null) {
      const points = [];

      // If we have labels, create points distributed by cluster
      if (labels && labels.length > 0) {
        const clusterCenters = {};
        const uniqueClusters = [...new Set(labels)].filter(c => c !== -1);

        // Generate cluster centers
        uniqueClusters.forEach((c, i) => {
          const angle = (i / uniqueClusters.length) * 2 * Math.PI;
          clusterCenters[c] = {
            x: Math.cos(angle) * 3,
            y: Math.sin(angle) * 3,
            z: (i % 3 - 1) * 2
          };
        });

        // Create points around cluster centers
        labels.forEach((cluster, idx) => {
          const center = clusterCenters[cluster] || { x: 0, y: 0, z: 0 };
          points.push({
            x: center.x + (Math.random() - 0.5) * 1.5,
            y: center.y + (Math.random() - 0.5) * 1.5,
            z: center.z + (Math.random() - 0.5) * 1.5,
            cluster: cluster
          });
        });

        return points;
      }

      // Original fallback: generate synthetic clusters
      const centers = [
        { x: 0, y: 0, z: 0 },
        { x: 3, y: 3, z: 2 },
        { x: -2, y: 2, z: 3 },
        { x: 2, y: -2, z: -1 },
        { x: -1, y: -3, z: 2 }
      ];

      for (let c = 0; c < Math.min(nClusters, 5); c++) {
        const center = centers[c];
        for (let i = 0; i < 30; i++) {
          points.push({
            x: center.x + (Math.random() - 0.5) * 2,
            y: center.y + (Math.random() - 0.5) * 2,
            z: center.z + (Math.random() - 0.5) * 2,
            cluster: c
          });
        }
      }
      return points;
    }

    // Render anomaly score distribution
    function renderAnomalyDistribution(anomalyData, containerId) {
      const container = document.getElementById(containerId);
      if (!container || !anomalyData) return;

      const scores = anomalyData.scores || anomalyData.anomaly_scores ||
        Array.from({ length: 100 }, () => Math.random() * 100);
      const threshold = anomalyData.threshold || 75;

      const data = [{
        type: 'histogram',
        x: scores,
        marker: {
          color: scores.map(s => s > threshold ? VIZ_COLORS.error : VIZ_COLORS.primary),
          line: { width: 1, color: 'rgba(255,255,255,0.2)' }
        },
        hovertemplate: 'Score: %{x:.1f}<br>Count: %{y}<extra></extra>'
      }];

      // Add threshold line
      const shapes = [{
        type: 'line',
        x0: threshold, x1: threshold,
        y0: 0, y1: 1,
        yref: 'paper',
        line: { color: VIZ_COLORS.error, width: 2, dash: 'dash' }
      }];

      Plotly.newPlot(container, data, {
        paper_bgcolor: 'transparent',
        plot_bgcolor: 'transparent',
        font: { color: VIZ_COLORS.textMuted },
        margin: { l: 50, r: 20, t: 20, b: 50 },
        xaxis: {
          title: 'Anomaly Score',
          gridcolor: 'rgba(255,255,255,0.05)'
        },
        yaxis: {
          title: 'Count',
          gridcolor: 'rgba(255,255,255,0.05)'
        },
        shapes: shapes,
        annotations: [{
          x: threshold,
          y: 1,
          yref: 'paper',
          text: 'Threshold',
          showarrow: false,
          font: { color: VIZ_COLORS.error, size: 11 }
        }]
      }, { responsive: true, displayModeBar: false });
    }

    // Render statistical overview - smart multi-panel visualization
    function renderBoxPlots(data, containerId) {
      const container = document.getElementById(containerId);
      if (!container || !data) {
        if (container) {
          container.innerHTML = '<p style="color:#94a3b8; text-align:center; padding:20px;">No statistical data available</p>';
        }
        return;
      }

      // Extract descriptive statistics
      const descriptive = data.descriptive?.numeric || data.numeric || {};
      const columns = Object.keys(descriptive);
      const correlation = data.correlation;
      const distribution = data.distribution;

      if (columns.length === 0 && !correlation && !distribution) {
        renderStatisticalSummary(data, container);
        return;
      }

      // Create a multi-panel layout
      container.innerHTML = `
        <div class="stat-viz-container" style="display:grid; grid-template-columns: 1fr 1fr; gap:16px; min-height:300px;">
          <div class="stat-panel" id="${containerId}-variability" style="background:rgba(0,0,0,0.3); border-radius:10px; padding:12px; border:1px solid rgba(255,255,255,0.1);"></div>
          <div class="stat-panel" id="${containerId}-correlation" style="background:rgba(0,0,0,0.3); border-radius:10px; padding:12px; border:1px solid rgba(255,255,255,0.1);"></div>
        </div>
      `;

      // Panel 1: Coefficient of Variation (normalized comparison)
      setTimeout(() => renderVariabilityChart(descriptive, `${containerId}-variability`), 50);

      // Panel 2: Correlation heatmap or distribution insights
      setTimeout(() => {
        if (correlation?.pearson && Object.keys(correlation.pearson).length > 1) {
          renderCorrelationHeatmap(correlation, `${containerId}-correlation`);
        } else if (distribution?.normality_tests) {
          renderDistributionChart(distribution, descriptive, `${containerId}-correlation`);
        } else {
          renderDescriptiveCards(descriptive, `${containerId}-correlation`);
        }
      }, 100);
    }

    // Coefficient of Variation chart - shows relative variability across all columns
    function renderVariabilityChart(descriptive, containerId) {
      const container = document.getElementById(containerId);
      if (!container) return;

      const columns = Object.keys(descriptive);
      if (columns.length === 0) {
        container.innerHTML = '<p style="color:#94a3b8; text-align:center;">No numeric data</p>';
        return;
      }

      // Calculate coefficient of variation (std/mean) - normalized measure
      const cvData = columns.map(col => {
        const stats = descriptive[col];
        const cv = stats.coefficient_of_variation || (stats.std / stats.mean) || 0;
        return {
          name: col,
          cv: Math.abs(cv) * 100, // as percentage
          mean: stats.mean,
          std: stats.std,
          skewness: stats.skewness || 0
        };
      }).sort((a, b) => b.cv - a.cv).slice(0, 10);

      const trace = {
        type: 'bar',
        x: cvData.map(d => d.cv),
        y: cvData.map(d => d.name.length > 15 ? d.name.substring(0, 15) + '...' : d.name),
        orientation: 'h',
        marker: {
          color: cvData.map(d => {
            if (d.cv > 100) return VIZ_COLORS.error;
            if (d.cv > 50) return VIZ_COLORS.warning;
            return VIZ_COLORS.accent;
          }),
          line: { color: 'rgba(255,255,255,0.2)', width: 1 }
        },
        hovertemplate: '<b>%{y}</b><br>' +
          'Variability: %{x:.1f}%<br>' +
          '<extra></extra>',
        text: cvData.map(d => d.cv.toFixed(1) + '%'),
        textposition: 'outside',
        textfont: { color: '#e2e8f0', size: 10 }
      };

      Plotly.newPlot(container, [trace], {
        paper_bgcolor: 'transparent',
        plot_bgcolor: 'transparent',
        font: { color: VIZ_COLORS.textMuted, size: 10 },
        margin: { l: 100, r: 50, t: 35, b: 30 },
        xaxis: {
          title: 'Coefficient of Variation (%)',
          gridcolor: 'rgba(255,255,255,0.05)',
          zeroline: false
        },
        yaxis: {
          automargin: true,
          tickfont: { size: 10 }
        },
        title: {
          text: 'ğŸ“Š Data Variability',
          font: { color: '#e2e8f0', size: 13 },
          x: 0.02,
          xanchor: 'left'
        }
      }, { responsive: true, displayModeBar: false });
    }

    // Correlation heatmap
    function renderCorrelationHeatmap(correlation, containerId) {
      const container = document.getElementById(containerId);
      if (!container) return;

      const pearson = correlation.pearson;
      const columns = correlation.columns || Object.keys(pearson);

      if (columns.length < 2) {
        container.innerHTML = '<p style="color:#94a3b8; text-align:center;">Need 2+ columns for correlation</p>';
        return;
      }

      // Limit to top 8 columns for readability
      const limitedCols = columns.slice(0, 8);

      // Build correlation matrix
      const zValues = limitedCols.map(row =>
        limitedCols.map(col => pearson[row]?.[col] || 0)
      );

      const trace = {
        type: 'heatmap',
        x: limitedCols.map(c => c.length > 10 ? c.substring(0, 10) + '..' : c),
        y: limitedCols.map(c => c.length > 10 ? c.substring(0, 10) + '..' : c),
        z: zValues,
        colorscale: [
          [0, '#ef4444'],
          [0.5, '#1e293b'],
          [1, '#10b981']
        ],
        zmin: -1,
        zmax: 1,
        hovertemplate: '%{y} â†” %{x}<br>Correlation: %{z:.2f}<extra></extra>',
        showscale: true,
        colorbar: {
          title: 'r',
          titleside: 'right',
          tickfont: { color: '#94a3b8', size: 9 },
          titlefont: { color: '#94a3b8', size: 10 }
        }
      };

      // Add correlation value annotations
      const annotations = [];
      limitedCols.forEach((row, i) => {
        limitedCols.forEach((col, j) => {
          const val = zValues[i][j];
          if (i !== j && Math.abs(val) > 0.3) {
            annotations.push({
              x: col.length > 10 ? col.substring(0, 10) + '..' : col,
              y: row.length > 10 ? row.substring(0, 10) + '..' : row,
              text: val.toFixed(2),
              font: { color: Math.abs(val) > 0.5 ? '#fff' : '#94a3b8', size: 9 },
              showarrow: false
            });
          }
        });
      });

      Plotly.newPlot(container, [trace], {
        paper_bgcolor: 'transparent',
        plot_bgcolor: 'transparent',
        font: { color: VIZ_COLORS.textMuted, size: 9 },
        margin: { l: 80, r: 50, t: 35, b: 80 },
        xaxis: { tickangle: -45, tickfont: { size: 9 } },
        yaxis: { tickfont: { size: 9 } },
        annotations: annotations,
        title: {
          text: 'ğŸ”— Correlation Matrix',
          font: { color: '#e2e8f0', size: 13 },
          x: 0.02,
          xanchor: 'left'
        }
      }, { responsive: true, displayModeBar: false });
    }

    // Distribution analysis chart
    function renderDistributionChart(distribution, descriptive, containerId) {
      const container = document.getElementById(containerId);
      if (!container) return;

      const normality = distribution.normality_tests || {};
      const columns = Object.keys(normality).slice(0, 10);

      if (columns.length === 0) {
        renderDescriptiveCards(descriptive, containerId);
        return;
      }

      // Skewness-Kurtosis scatter
      const skewData = columns.map(col => ({
        name: col,
        skewness: descriptive[col]?.skewness || 0,
        kurtosis: descriptive[col]?.kurtosis || 0,
        isNormal: normality[col]?.is_normal || false
      }));

      const trace = {
        type: 'scatter',
        mode: 'markers+text',
        x: skewData.map(d => d.skewness),
        y: skewData.map(d => d.kurtosis),
        text: skewData.map(d => d.name.length > 8 ? d.name.substring(0, 8) + '..' : d.name),
        textposition: 'top center',
        textfont: { size: 9, color: '#94a3b8' },
        marker: {
          size: 14,
          color: skewData.map(d => d.isNormal ? VIZ_COLORS.accent : VIZ_COLORS.warning),
          line: { color: 'rgba(255,255,255,0.3)', width: 1 }
        },
        hovertemplate: '<b>%{text}</b><br>Skewness: %{x:.2f}<br>Kurtosis: %{y:.2f}<extra></extra>'
      };

      // Add reference zone for normal distribution (skew~0, kurtosis~0)
      const shapes = [{
        type: 'circle',
        xref: 'x',
        yref: 'y',
        x0: -0.5,
        y0: -0.5,
        x1: 0.5,
        y1: 0.5,
        fillcolor: 'rgba(16, 185, 129, 0.1)',
        line: { color: 'rgba(16, 185, 129, 0.3)', dash: 'dot' }
      }];

      Plotly.newPlot(container, [trace], {
        paper_bgcolor: 'transparent',
        plot_bgcolor: 'transparent',
        font: { color: VIZ_COLORS.textMuted, size: 10 },
        margin: { l: 50, r: 20, t: 35, b: 50 },
        xaxis: {
          title: 'Skewness',
          zeroline: true,
          zerolinecolor: 'rgba(255,255,255,0.2)',
          gridcolor: 'rgba(255,255,255,0.05)'
        },
        yaxis: {
          title: 'Kurtosis',
          zeroline: true,
          zerolinecolor: 'rgba(255,255,255,0.2)',
          gridcolor: 'rgba(255,255,255,0.05)'
        },
        shapes: shapes,
        title: {
          text: 'ğŸ“ˆ Distribution Shape',
          font: { color: '#e2e8f0', size: 13 },
          x: 0.02,
          xanchor: 'left'
        }
      }, { responsive: true, displayModeBar: false });
    }

    // Descriptive stats cards (fallback)
    function renderDescriptiveCards(descriptive, containerId) {
      const container = document.getElementById(containerId);
      if (!container) return;

      const columns = Object.keys(descriptive).slice(0, 6);

      let html = `
        <div style="padding:8px;">
          <h6 style="color:#e2e8f0; font-size:13px; margin:0 0 12px 0;">ğŸ“‹ Key Statistics</h6>
          <div style="display:grid; grid-template-columns:repeat(2, 1fr); gap:8px;">
      `;

      columns.forEach(col => {
        const stats = descriptive[col];
        const formatNum = n => {
          if (Math.abs(n) >= 1e6) return (n / 1e6).toFixed(1) + 'M';
          if (Math.abs(n) >= 1e3) return (n / 1e3).toFixed(1) + 'K';
          return n.toFixed(2);
        };

        html += `
          <div style="background:rgba(6,182,212,0.08); padding:10px; border-radius:8px; border-left:3px solid #06b6d4;">
            <div style="font-weight:600; color:#22d3ee; font-size:0.8rem; margin-bottom:6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;" title="${col}">${col}</div>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:4px; font-size:0.75rem; color:#cbd5e1;">
              <span>Î¼: ${formatNum(stats.mean || 0)}</span>
              <span>Ïƒ: ${formatNum(stats.std || 0)}</span>
              <span>Min: ${formatNum(stats.min || 0)}</span>
              <span>Max: ${formatNum(stats.max || 0)}</span>
            </div>
          </div>
        `;
      });

      html += '</div></div>';
      container.innerHTML = html;
    }

    // Fallback: render a statistical summary when nothing else works
    function renderStatisticalSummary(data, container) {
      let html = '<div class="stat-summary-grid" style="display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:12px; padding:10px;">';

      // Check for correlation data
      if (data.correlation?.strong_correlations?.length > 0) {
        html += '<div class="stat-card" style="background:rgba(6,182,212,0.1); padding:14px; border-radius:10px; border-left:3px solid #06b6d4;">';
        html += '<h6 style="color:#22d3ee; margin:0 0 10px 0; font-size:0.9rem;">ğŸ”— Strong Correlations</h6>';
        data.correlation.strong_correlations.slice(0, 4).forEach(c => {
          const color = c.correlation > 0 ? '#10b981' : '#f59e0b';
          html += `<div style="font-size:0.85rem; color:#e2e8f0; margin:6px 0;">
            <span style="color:${color}">${c.correlation > 0 ? 'â†—' : 'â†˜'}</span> 
            ${c.column1} â†” ${c.column2}: <strong style="color:${color}">${(c.correlation * 100).toFixed(0)}%</strong>
          </div>`;
        });
        html += '</div>';
      }

      // Show metadata summary
      if (data.metadata) {
        html += '<div class="stat-card" style="background:rgba(168,85,247,0.1); padding:14px; border-radius:10px; border-left:3px solid #a855f7;">';
        html += '<h6 style="color:#c084fc; margin:0 0 10px 0; font-size:0.9rem;">ğŸ“‹ Dataset Info</h6>';
        html += `<div style="font-size:0.85rem; color:#e2e8f0;">Rows: <strong>${data.metadata.rows?.toLocaleString() || 'N/A'}</strong></div>`;
        html += `<div style="font-size:0.85rem; color:#e2e8f0;">Columns: <strong>${data.metadata.columns || 'N/A'}</strong></div>`;
        html += '</div>';
      }

      // If we have summary highlights
      if (data.summary?.highlights?.length > 0) {
        html += '<div class="stat-card" style="background:rgba(245,158,11,0.1); padding:14px; border-radius:10px; border-left:3px solid #f59e0b; grid-column: span 2;">';
        html += '<h6 style="color:#fbbf24; margin:0 0 10px 0; font-size:0.9rem;">ğŸ’¡ Key Insights</h6>';
        data.summary.highlights.slice(0, 5).forEach(h => {
          html += `<div style="font-size:0.85rem; color:#e2e8f0; margin:6px 0;">â€¢ ${h}</div>`;
        });
        html += '</div>';
      }

      html += '</div>';

      if (html === '<div class="stat-summary-grid" style="display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:12px; padding:10px;"></div>') {
        html = '<p style="color:#94a3b8; text-align:center; padding:20px;">Statistical analysis complete. View full results below for details.</p>';
      }

      container.innerHTML = html;
    }

    // ========== END ADVANCED VISUALIZATIONS ==========

    function renderMethodology(expl) {
      const c = document.getElementById('methodology-container');
      if (!expl.methodology_name) { c.innerHTML = '<p style="color:#94a3b8;">Not available</p>'; return; }
      let html = '<div class="methodology-title">ğŸ“š ' + expl.methodology_name + (expl.methodology_url ? ' <a href="' + expl.methodology_url + '" target="_blank">Learn more â†’</a>' : '') + '</div>';
      if (expl.steps?.length) {
        html += '<div class="step-list">' + expl.steps.map(s => '<div class="step-item"><div class="step-number">' + s.step_number + '</div><div class="step-content"><div class="step-title">' + s.title + '</div><div class="step-desc">' + s.description + '</div></div></div>').join('') + '</div>';
      }
      if (expl.limitations?.length) {
        html += '<div style="margin-top:20px;"><div style="font-weight:600;color:#f59e0b;margin-bottom:10px;">âš ï¸ Limitations</div><ul class="limitations-list">' + expl.limitations.map(l => '<li>' + l + '</li>').join('') + '</ul></div>';
      }
      c.innerHTML = html;
    }

    function renderHoldout(holdout) {
      const section = document.getElementById('holdout-section');
      const c = document.getElementById('holdout-container');
      if (!holdout || !Object.keys(holdout).length) { section.style.display = 'none'; return; }
      section.style.display = 'block';
      let html = '<p style="margin:0 0 12px;color:#cbd5e1;">We tested on held-out data:</p><div class="holdout-metrics">';
      if (holdout.accuracy !== undefined) html += '<div class="holdout-metric"><div class="holdout-metric-value">' + (holdout.accuracy * 100).toFixed(1) + '%</div><div class="holdout-metric-label">Accuracy</div></div>';
      if (holdout.precision !== undefined) html += '<div class="holdout-metric"><div class="holdout-metric-value">' + (holdout.precision * 100).toFixed(1) + '%</div><div class="holdout-metric-label">Precision</div></div>';
      if (holdout.recall !== undefined) html += '<div class="holdout-metric"><div class="holdout-metric-value">' + (holdout.recall * 100).toFixed(1) + '%</div><div class="holdout-metric-label">Recall</div></div>';
      if (holdout.f1_score !== undefined) html += '<div class="holdout-metric"><div class="holdout-metric-value">' + (holdout.f1_score * 100).toFixed(1) + '%</div><div class="holdout-metric-label">F1 Score</div></div>';
      html += '</div>';
      c.innerHTML = html;
    }

    function renderWarnings(warnings) {
      const section = document.getElementById('warnings-section');
      const c = document.getElementById('warnings-container');
      if (!warnings.length) { section.style.display = 'none'; return; }
      section.style.display = 'block';
      c.innerHTML = warnings.map(w => '<div class="warning-item"><span>âš ï¸</span><span>' + w + '</span></div>').join('');
    }

    function renderConfig(schema) {
      const c = document.getElementById('config-container');
      if (!schema.length) { c.innerHTML = '<p style="color:#94a3b8;">No options</p>'; return; }
      c.innerHTML = schema.map(cfg => '<div class="config-item"><div class="config-name">' + cfg.name + '</div><div class="config-value">Default: ' + cfg.default + (cfg.range ? ' (' + (Array.isArray(cfg.range) ? cfg.range.join(' - ') : cfg.range) + ')' : '') + '</div>' + (cfg.description ? '<div class="config-desc">' + cfg.description + '</div>' : '') + '</div>').join('');
    }

    // ========== Chronos Forecasting Functions ==========
    function detectTimeColumns() {
      // Time column detection patterns
      const timePatterns = [
        /date/i, /time/i, /timestamp/i, /datetime/i, /dt$/i, /_dt$/i,
        /created/i, /updated/i, /modified/i, /posted/i,
        /^day$/i, /^month$/i, /^year$/i, /period/i,
        /_at$/i, /_on$/i
      ];

      const detectedTimeCols = uploadedColumns.filter(col =>
        timePatterns.some(pattern => pattern.test(col))
      );

      hasTimeColumn = detectedTimeCols.length > 0;

      if (hasTimeColumn) {
        // Auto-select first detected time column
        detectedTimeColumn = detectedTimeCols[0];

        // Populate time column dropdown
        const timeSelect = document.getElementById('forecast-time-col');
        if (timeSelect) {
          timeSelect.innerHTML = detectedTimeCols.map(col =>
            '<option value="' + col + '"' + (col === detectedTimeColumn ? ' selected' : '') + '>' + col + '</option>'
          ).join('');
        }

        // Populate target column dropdown (numeric columns, exclude time columns)
        const numericPatterns = [
          /amount/i, /price/i, /value/i, /count/i, /total/i, /sum/i,
          /score/i, /rate/i, /percent/i, /qty/i, /quantity/i,
          /sales/i, /revenue/i, /cost/i, /profit/i, /num/i
        ];

        const potentialTargets = uploadedColumns.filter(col =>
          !timePatterns.some(p => p.test(col)) &&
          (numericPatterns.some(p => p.test(col)) || !isNaN(col.charAt(0)))
        );

        // If no numeric patterns found, use all non-time columns
        const targetOptions = potentialTargets.length > 0 ? potentialTargets :
          uploadedColumns.filter(col => !timePatterns.some(p => p.test(col)));

        detectedTargetColumn = targetOptions[0] || uploadedColumns.find(col => col !== detectedTimeColumn);

        const targetSelect = document.getElementById('forecast-target-col');
        if (targetSelect) {
          targetSelect.innerHTML = targetOptions.map(col =>
            '<option value="' + col + '"' + (col === detectedTargetColumn ? ' selected' : '') + '>' + col + '</option>'
          ).join('');
        }

        // Show forecast tab button
        const forecastTabBtn = document.getElementById('forecasting-tab-btn');
        if (forecastTabBtn) {
          forecastTabBtn.style.display = '';
        }

        log('ğŸ”® Time column detected: ' + detectedTimeColumn, 'success');
        log('ğŸ“ˆ Auto-selected forecast target: ' + detectedTargetColumn, 'info');
        return true;
      }

      return false;
    }

    async function runChronosForecast() {
      const timeCol = document.getElementById('forecast-time-col')?.value || detectedTimeColumn;
      const targetCol = document.getElementById('forecast-target-col')?.value || detectedTargetColumn;
      const periods = parseInt(document.getElementById('forecast-periods')?.value || '30');

      if (!timeCol || !targetCol) {
        log('Cannot run forecast: missing time or target column', 'error');
        const statusDiv = document.getElementById('forecast-status');
        if (statusDiv) {
          statusDiv.style.display = 'block';
          statusDiv.style.background = 'rgba(239,68,68,0.1)';
          statusDiv.style.borderColor = 'rgba(239,68,68,0.3)';
          statusDiv.innerHTML = '<span style="color:#ef4444;">âŒ Please select both a time column and a target value to forecast.</span>';
        }
        return;
      }

      // Show loading state
      const statusDiv = document.getElementById('forecast-status');
      if (statusDiv) {
        statusDiv.style.display = 'block';
        statusDiv.style.background = 'rgba(6,182,212,0.1)';
        statusDiv.style.border = '1px solid rgba(6,182,212,0.3)';
        statusDiv.innerHTML = '<span style="color:#67e8f9;">â³ Running 6 Prophet variant models for ' + targetCol + ' (' + periods + ' periods)...</span>';
      }

      // Disable button while running
      const runBtn = document.getElementById('run-forecast-btn');
      if (runBtn) runBtn.disabled = true;

      log('ğŸ”® Running Chronos multi-variant forecast: ' + targetCol + ' over ' + periods + ' periods', 'info');

      try {
        const requestBody = {
          filename: uploadedFilename,
          config_overrides: {
            time_column: timeCol,
            target_column: targetCol,
            forecast_periods: periods,
            run_all_variants: true  // Run all Prophet configurations for comparison
          }
        };

        const res = await fetch(API_BASE + '/analytics/premium/chronos', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify(requestBody)
        });

        const data = await res.json();
        console.log('Chronos Response:', data);

        if (data.error || (data.detail && res.status >= 400)) {
          throw new Error(errorToString(data.error || data.detail));
        }

        forecastResults = data;

        // Show success status with variant count
        const variantCount = data.all_variants?.length || 1;
        const bestName = data.best_variant_name || 'Prophet';
        if (statusDiv) {
          statusDiv.style.background = 'rgba(16,185,129,0.1)';
          statusDiv.style.border = '1px solid rgba(16,185,129,0.3)';
          statusDiv.innerHTML = '<span style="color:#10b981;">âœ… Compared ' + variantCount + ' models! Best: ' + bestName + ' with ' + (data.forecast?.length || 0) + ' data points.</span>';
        }

        renderForecastChart();
        log('ğŸ”® Forecast complete!', 'success');

      } catch (err) {
        log('Forecast error: ' + err.message, 'error');
        if (statusDiv) {
          statusDiv.style.background = 'rgba(239,68,68,0.1)';
          statusDiv.style.border = '1px solid rgba(239,68,68,0.3)';
          statusDiv.innerHTML = '<span style="color:#ef4444;">âŒ Forecast failed: ' + err.message + '</span>';
        }
      } finally {
        if (runBtn) runBtn.disabled = false;
      }
    }

    function renderForecastChart() {
      if (!forecastResults) return;

      // Show results container
      const resultsDiv = document.getElementById('forecast-results');
      if (resultsDiv) {
        resultsDiv.style.display = 'block';
      }

      // Hide "no time data" message
      const noDataDiv = document.getElementById('no-time-data');
      if (noDataDiv) {
        noDataDiv.style.display = 'none';
      }

      // Extract forecast data
      const forecast = forecastResults.forecast || [];
      const metrics = forecastResults.metrics || {};
      const insights = forecastResults.insights || [];

      // Prepare chart data
      const labels = forecast.map(f => {
        // Format date for display
        const d = new Date(f.ds);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      });

      const predictions = forecast.map(f => f.yhat);
      const lowerBound = forecast.map(f => f.yhat_lower);
      const upperBound = forecast.map(f => f.yhat_upper);

      // Determine split between historical and forecast (estimate)
      const historicalCount = Math.floor(forecast.length * 0.7);  // Assume ~70% is historical

      // Destroy existing chart if any
      if (charts.forecast) {
        charts.forecast.destroy();
      }

      const ctx = document.getElementById('forecast-chart');
      if (!ctx) return;

      charts.forecast = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Confidence Range (Upper)',
              data: upperBound,
              borderColor: 'transparent',
              backgroundColor: 'rgba(6, 182, 212, 0.12)',
              fill: '+1',
              pointRadius: 0,
              tension: 0.4
            },
            {
              label: 'Confidence Range (Lower)',
              data: lowerBound,
              borderColor: 'transparent',
              backgroundColor: 'transparent',
              fill: false,
              pointRadius: 0,
              tension: 0.4
            },
            {
              label: 'Predicted Values',
              data: predictions,
              borderColor: '#06b6d4',
              backgroundColor: 'rgba(6, 182, 212, 0.1)',
              borderWidth: 2.5,
              fill: false,
              pointRadius: 0,
              pointHoverRadius: 6,
              pointHoverBackgroundColor: '#22d3ee',
              pointHoverBorderColor: '#0a0f1c',
              pointHoverBorderWidth: 2,
              tension: 0.4
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false
          },
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: 'rgba(10, 15, 28, 0.95)',
              titleColor: '#22d3ee',
              bodyColor: '#f1f5f9',
              borderColor: 'rgba(6, 182, 212, 0.4)',
              borderWidth: 1,
              cornerRadius: 8,
              padding: 14,
              callbacks: {
                title: function (ctx) {
                  return 'Date: ' + ctx[0].label;
                },
                label: function (ctx) {
                  if (ctx.datasetIndex === 2) {
                    const idx = ctx.dataIndex;
                    const lower = lowerBound[idx]?.toFixed(2) || 'N/A';
                    const upper = upperBound[idx]?.toFixed(2) || 'N/A';
                    return [
                      'Predicted: ' + ctx.parsed.y.toFixed(2),
                      'Range: ' + lower + ' - ' + upper
                    ];
                  }
                  return null;
                }
              }
            }
          },
          scales: {
            x: {
              grid: {
                color: 'rgba(6, 182, 212, 0.06)',
                drawBorder: false
              },
              ticks: {
                color: '#94a3b8',
                maxTicksLimit: 8,
                font: { weight: '500' }
              }
            },
            y: {
              grid: {
                color: 'rgba(6, 182, 212, 0.06)',
                drawBorder: false
              },
              ticks: {
                color: '#94a3b8'
              }
            }
          }
        }
      });

      // Update stats
      // Note: MAPE from backend is already a percentage (e.g., 1.09 = 1.09%, not 109%)
      const mapeRaw = metrics.mape || metrics.MAPE;
      // Normalize: if MAPE > 1, it's already a percentage; if < 1, convert to percentage
      const mape = mapeRaw !== undefined ? (mapeRaw > 1 ? mapeRaw : mapeRaw * 100) : undefined;
      const mapeDisplay = mape !== undefined ? formatPreciseAccuracy(mape) + '%' : 'N/A';
      document.getElementById('forecast-mape').textContent = mapeDisplay;

      // Get target column name
      const targetCol = document.getElementById('forecast-target-col')?.value || detectedTargetColumn || 'the target';

      // Calculate trend
      let trendText = 'â†’ Stable';
      let explanationText = '';
      if (predictions.length >= 2) {
        const lastVal = predictions[predictions.length - 1];
        const firstVal = predictions[0];
        const pctChange = ((lastVal - firstVal) / Math.abs(firstVal) * 100);
        trendText = pctChange > 2 ? 'â†‘ Upward' : pctChange < -2 ? 'â†“ Downward' : 'â†’ Stable';
        document.getElementById('forecast-trend').textContent = trendText;

        // Next period value
        document.getElementById('forecast-next').textContent = lastVal?.toFixed(2) || 'N/A';

        // Final period value (range)
        const lastLower = lowerBound[lowerBound.length - 1];
        const lastUpper = upperBound[upperBound.length - 1];
        document.getElementById('forecast-final').textContent =
          (lastLower?.toFixed(1) || '?') + ' - ' + (lastUpper?.toFixed(1) || '?');

        // Generate explanation
        const direction = pctChange > 2 ? 'increase' : pctChange < -2 ? 'decrease' : 'remain stable';
        const confidenceWidth = lastUpper - lastLower;
        const confidenceLevel = confidenceWidth < Math.abs(lastVal) * 0.1 ? 'high' :
          confidenceWidth < Math.abs(lastVal) * 0.3 ? 'moderate' : 'wide';

        explanationText = `Based on historical patterns, ${targetCol} is projected to ${direction} over the forecast period. ` +
          `The ${confidenceLevel} confidence interval shows the range of likely values, ` +
          `with prediction uncertainty growing further into the future.`;

        if (mape !== undefined) {
          explanationText += ` Model accuracy (MAPE): ${mapeDisplay} - ` +
            (mape < 0.1 ? 'excellent fit.' : mape < 0.2 ? 'good fit.' : 'moderate fit, interpret with caution.');
        }
      }

      // Set explanation
      const explanationDiv = document.getElementById('forecast-explanation');
      if (explanationDiv) {
        explanationDiv.innerHTML = renderMarkdown(explanationText);
      }

      // Render insights from backend
      const insightsContainer = document.getElementById('forecast-insights');
      if (insightsContainer) {
        if (insights.length > 0) {
          insightsContainer.style.display = 'block';
          insightsContainer.innerHTML = '<div style="font-weight:500;color:#67e8f9;margin-bottom:8px;">ğŸ’¡ Key Insights:</div>' +
            insights.map(insight =>
              '<div style="display:flex;align-items:flex-start;gap:8px;margin-bottom:6px;">' +
              '<span style="color:#06b6d4;">â€¢</span><span style="color:#cbd5e1;font-size:0.9rem;">' + insight + '</span></div>'
            ).join('');
        } else {
          insightsContainer.style.display = 'none';
        }
      }

      // ========== Update Accuracy Hero Section ==========
      updateAccuracyHero(mape, metrics, forecast, trendText);

      // ========== Update Forecast Overview Card in Overview Tab ==========
      updateForecastOverviewCard(mape, trendText, forecast.length, targetCol);

      // ========== Render All Variants with High-Precision Accuracy ==========
      renderForecastVariants(forecastResults);

      // ========== Trigger Automatic Gemma Explanation ==========
      // Small delay to ensure Gemma model is loaded (timed with other Gemma events)
      setTimeout(() => {
        requestGemmaForecastExplanation(mape, trendText, targetCol, metrics, forecast);
      }, 500);
    }

    // ========== Accuracy Hero Update Function ==========
    function updateAccuracyHero(mape, metrics, forecast, trendText) {
      // Calculate accuracy percentage (100% - MAPE)
      // mape is already normalized to percentage in renderForecastChart
      const accuracyPercent = mape !== undefined ? Math.max(0, 100 - mape) : 0;

      // Update circular progress ring
      const progressCircle = document.getElementById('accuracy-progress');
      if (progressCircle) {
        // Circumference = 2 * PI * radius (40)
        const circumference = 2 * Math.PI * 40;
        const offset = circumference - (accuracyPercent / 100) * circumference;
        progressCircle.style.strokeDashoffset = offset;
      }

      // Update center text - use high precision for high accuracy
      const percentText = document.getElementById('accuracy-percent');
      if (percentText) {
        percentText.textContent = formatPreciseAccuracy(accuracyPercent) + '%';
      }

      // Determine rating based on MAPE percentage
      // MAPE thresholds: <5% exceptional, <10% excellent, <20% good, <50% fair, else poor
      let rating, ratingClass, ratingEmoji, subtitle;
      if (mape !== undefined && mape < 5) {
        rating = 'Exceptional';
        ratingClass = 'rating-excellent';
        ratingEmoji = 'ğŸŒŸ';
        subtitle = 'Our model predicts with exceptional accuracy. Your forecasts are highly reliable for strategic planning and business decisions.';
      } else if (mape !== undefined && mape < 10) {
        rating = 'Excellent';
        ratingClass = 'rating-excellent';
        ratingEmoji = 'âœ¨';
        subtitle = 'Excellent forecast accuracy. These predictions are reliable for planning and can be used with high confidence.';
      } else if (mape !== undefined && mape < 20) {
        rating = 'Good';
        ratingClass = 'rating-good';
        ratingEmoji = 'âœ…';
        subtitle = 'Good forecast accuracy. ML Service are suitable for general planning, though some variance is expected.';
      } else if (mape !== undefined && mape < 50) {
        rating = 'Fair';
        ratingClass = 'rating-fair';
        ratingEmoji = 'âš ï¸';
        subtitle = 'Moderate accuracy. Use these predictions as directional guidance. Consider combining with other data sources.';
      } else {
        rating = 'Poor';
        ratingClass = 'rating-fair';
        ratingEmoji = 'âŒ';
        subtitle = 'Low accuracy. This data may be too volatile or noisy for reliable forecasting. Use with caution.';
      }

      // Update hero title and badge
      const heroTitle = document.getElementById('hero-accuracy-title');
      if (heroTitle) heroTitle.textContent = formatPreciseAccuracy(accuracyPercent) + '% Forecast Accuracy';

      const ratingBadge = document.getElementById('hero-rating-badge');
      if (ratingBadge) {
        ratingBadge.className = 'rating-badge ' + ratingClass;
        ratingBadge.textContent = ratingEmoji + ' ' + rating;
      }

      const heroSubtitle = document.getElementById('hero-accuracy-subtitle');
      if (heroSubtitle) heroSubtitle.textContent = subtitle;

      // Update mini stats with precision
      const maeEl = document.getElementById('hero-mae');
      if (maeEl) maeEl.textContent = formatPreciseValue(metrics.mae || metrics.MAE || 0);

      const rmseEl = document.getElementById('hero-rmse');
      if (rmseEl) rmseEl.textContent = formatPreciseValue(metrics.rmse || metrics.RMSE || 0);

      const periodsEl = document.getElementById('hero-periods');
      if (periodsEl) periodsEl.textContent = forecast.length;
    }

    // ========== Update Forecast Overview in Overview Tab ==========
    function updateForecastOverviewCard(mape, trendText, periods, targetCol) {
      const card = document.getElementById('forecast-overview-card');
      if (!card) return;

      // Show the card
      card.classList.add('visible');

      // Calculate accuracy percentage (mape is already a percentage)
      const accuracyPercent = mape !== undefined ? Math.max(0, 100 - mape) : 0;

      // Update rating badge based on MAPE percentage thresholds
      let ratingClass, ratingText;
      if (mape !== undefined && mape < 5) {
        ratingClass = 'rating-excellent';
        ratingText = 'ğŸŒŸ Exceptional';
      } else if (mape !== undefined && mape < 10) {
        ratingClass = 'rating-excellent';
        ratingText = 'âœ¨ Excellent';
      } else if (mape !== undefined && mape < 20) {
        ratingClass = 'rating-good';
        ratingText = 'âœ… Good';
      } else if (mape !== undefined && mape < 50) {
        ratingClass = 'rating-fair';
        ratingText = 'âš ï¸ Fair';
      } else {
        ratingClass = 'rating-fair';
        ratingText = 'âŒ Poor';
      }

      const ratingEl = document.getElementById('forecast-overview-rating');
      if (ratingEl) {
        ratingEl.className = 'forecast-overview-accuracy ' + ratingClass;
        ratingEl.textContent = ratingText;
      }

      // Update stats with precision
      const mapeEl = document.getElementById('forecast-overview-mape');
      if (mapeEl) mapeEl.textContent = formatPreciseAccuracy(accuracyPercent) + '%';

      const trendEl = document.getElementById('forecast-overview-trend');
      if (trendEl) trendEl.textContent = trendText;

      const periodsEl = document.getElementById('forecast-overview-periods');
      if (periodsEl) periodsEl.textContent = periods;

      const targetEl = document.getElementById('forecast-overview-target');
      if (targetEl) targetEl.textContent = targetCol;
    }

    // ========== Render All Forecast Variants with High-Precision Accuracy ==========
    function renderForecastVariants(data) {
      const variantsContainer = document.getElementById('forecast-variants');
      const grid = document.getElementById('variants-comparison-grid');
      const countLabel = document.getElementById('variant-count-label');

      if (!variantsContainer || !grid) return;

      const allVariants = data.all_variants || [];

      if (allVariants.length === 0) {
        variantsContainer.style.display = 'none';
        return;
      }

      // Show container
      variantsContainer.style.display = 'block';

      // Update count label
      if (countLabel) {
        countLabel.textContent = `(${allVariants.length} models tested)`;
      }

      // Sort by accuracy (highest first = lowest MAPE)
      const sorted = [...allVariants].sort((a, b) =>
        (a.metrics?.mape || 999) - (b.metrics?.mape || 999)
      );

      // Generate cards for each variant
      grid.innerHTML = sorted.map((variant, index) => {
        const metrics = variant.metrics || {};
        const config = variant.config || {};
        const isBest = index === 0;

        // Calculate precision accuracy - show full precision
        const mape = metrics.mape || 0;
        const accuracy = metrics.accuracy !== undefined ? metrics.accuracy : Math.max(0, 100 - mape);

        // Format accuracy with high precision - show as many decimals as needed
        const accuracyDisplay = formatPreciseAccuracy(accuracy);
        const mapeDisplay = formatPreciseValue(mape);

        // Rank styling
        let rankClass = 'rank-' + (index + 1);
        if (index > 2) rankClass = '';

        // Config pills
        const configPills = [
          config.growth ? `<span class="variant-config-pill">${config.growth}</span>` : '',
          config.seasonality_mode ? `<span class="variant-config-pill">${config.seasonality_mode}</span>` : '',
          config.changepoint_prior_scale ? `<span class="variant-config-pill">flex: ${config.changepoint_prior_scale}</span>` : ''
        ].filter(Boolean).join('');

        return `
          <div class="variant-card ${isBest ? 'best' : ''}" data-variant="${variant.short_name}">
            <div class="variant-header">
              <div class="variant-name">${variant.name || 'Unknown'}</div>
              <div class="variant-badge ${rankClass}">#${index + 1}</div>
            </div>
            
            <div class="variant-accuracy-precise">
              <span class="label">Accuracy</span>
              <span class="value">${accuracyDisplay}%</span>
            </div>
            
            <div style="margin-bottom: 10px;">
              ${configPills}
            </div>
            
            <div style="font-size: 0.8rem; color: #94a3b8; margin-bottom: 10px; line-height: 1.4;">
              ${variant.description || ''}
            </div>
            
            <div class="variant-metrics-grid">
              <div class="variant-metric">
                <div class="metric-value">${formatPreciseValue(metrics.mae || 0)}</div>
                <div class="metric-label">MAE</div>
              </div>
              <div class="variant-metric">
                <div class="metric-value">${formatPreciseValue(metrics.rmse || 0)}</div>
                <div class="metric-label">RMSE</div>
              </div>
              <div class="variant-metric">
                <div class="metric-value">${mapeDisplay}%</div>
                <div class="metric-label">MAPE</div>
              </div>
            </div>
            
            <div style="margin-top: 10px; font-size: 0.75rem; color: #64748b; text-align: center;">
              â±ï¸ ${(variant.execution_time_seconds || 0).toFixed(3)}s
            </div>
          </div>
        `;
      }).join('');

      log('ğŸ† Displayed ' + allVariants.length + ' Prophet variants with precision accuracy', 'info');
    }

    // Format accuracy with high precision (removes trailing zeros but keeps meaningful decimals)
    function formatPreciseAccuracy(value) {
      if (value === undefined || value === null || isNaN(value)) return '0';

      // For very high accuracy (99.9+), show more decimals
      if (value >= 99.9) {
        return value.toFixed(10).replace(/\.?0+$/, '');
      }
      // For high accuracy (90+), show up to 6 decimals
      if (value >= 90) {
        return value.toFixed(6).replace(/\.?0+$/, '');
      }
      // For moderate accuracy, show up to 4 decimals
      if (value >= 50) {
        return value.toFixed(4).replace(/\.?0+$/, '');
      }
      // For low accuracy, show 2 decimals
      return value.toFixed(2);
    }

    // Format any metric value with appropriate precision
    function formatPreciseValue(value) {
      if (value === undefined || value === null || isNaN(value)) return '0';

      // For very small values, show more decimals
      if (Math.abs(value) < 0.01) {
        return value.toFixed(10).replace(/\.?0+$/, '');
      }
      // For small values, show up to 6 decimals
      if (Math.abs(value) < 1) {
        return value.toFixed(6).replace(/\.?0+$/, '');
      }
      // For normal values, show 4 decimals
      if (Math.abs(value) < 100) {
        return value.toFixed(4).replace(/\.?0+$/, '');
      }
      // For large values, show 2 decimals
      return value.toFixed(2);
    }

    // ========== Automatic Gemma Forecast Explanation ==========
    async function requestGemmaForecastExplanation(mape, trendText, targetCol, metrics, forecast) {
      // Prevent concurrent Gemma calls - ensures no mixing of responses
      if (gemmaExplanationPending) {
        log('â³ Waiting for previous Gemma request to complete...', 'info');
        return;
      }

      gemmaExplanationPending = true;

      // Show loading state
      const explanationCard = document.getElementById('forecast-gemma-explanation');
      const loadingDiv = document.getElementById('gemma-explain-loading');
      const textDiv = document.getElementById('gemma-explain-text');
      const statusEl = document.getElementById('gemma-explain-status');

      if (explanationCard) explanationCard.classList.add('visible');
      if (loadingDiv) loadingDiv.style.display = 'flex';
      if (textDiv) textDiv.style.display = 'none';
      if (statusEl) statusEl.textContent = 'Analyzing...';

      log('ğŸ¤– Gemma analyzing forecast results...', 'info');

      // Calculate key metrics for the prompt
      // mape is already a percentage (e.g., 1.09 = 1.09%)
      const accuracyPercent = mape !== undefined ? Math.max(0, 100 - mape).toFixed(1) : 'N/A';
      const firstVal = forecast[0]?.yhat?.toFixed(2) || 'N/A';
      const lastVal = forecast[forecast.length - 1]?.yhat?.toFixed(2) || 'N/A';
      const periods = forecast.length;
      const maeVal = (metrics.mae || metrics.MAE || 0).toFixed(2);
      const rmseVal = (metrics.rmse || metrics.RMSE || 0).toFixed(2);

      const prompt = `You are explaining a time-series forecast to a business user. Be clear, simple, and helpful.

FORECAST RESULTS:
- Target Variable: ${targetCol}
- Accuracy: ${accuracyPercent}% (MAPE: ${mape?.toFixed(2) || 'N/A'}%)
- Trend: ${trendText}
- Forecast periods: ${periods}
- Starting value: ${firstVal}
- Ending value: ${lastVal}
- MAE: ${maeVal}
- RMSE: ${rmseVal}

Write a 2-3 sentence explanation that:
1. Explains what the accuracy means in plain terms
2. Describes the trend and what to expect
3. Gives one actionable insight

Use simple language a business person can understand. No technical jargon.`;

      try {
        const res = await fetch(API_BASE + '/api/public/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({
            messages: [{ role: 'user', content: prompt }],
            max_tokens: 300
          })
        });

        const data = await res.json();
        const explanation = data.message || data.response || 'Unable to generate explanation.';

        lastGemmaExplanation = explanation;

        // Update UI with explanation (using markdown renderer)
        if (loadingDiv) loadingDiv.style.display = 'none';
        if (textDiv) {
          textDiv.style.display = 'block';
          textDiv.innerHTML = renderMarkdown(explanation);
        }
        if (statusEl) statusEl.textContent = 'Complete';

        log('ğŸ¤– Gemma explanation ready', 'success');

      } catch (err) {
        console.warn('Gemma explanation failed:', err);
        if (loadingDiv) loadingDiv.style.display = 'none';
        if (textDiv) {
          textDiv.style.display = 'block';
          textDiv.textContent = 'Unable to generate AI explanation at this time. Please check the metrics above for forecast details.';
        }
        if (statusEl) statusEl.textContent = 'Unavailable';
        log('âš ï¸ Gemma explanation unavailable', 'warning');
      } finally {
        gemmaExplanationPending = false;
      }
    }

    function updateForecastPeriods(value) {
      document.getElementById('forecast-periods-value').textContent = value;
    }

    function updateForecastPeriodLabel() {
      const value = document.getElementById('forecast-periods').value;
      document.getElementById('forecast-periods-label').textContent = value + ' days';
    }

    function onForecastConfigChange() {
      // User changed time or target column - reset status
      const statusDiv = document.getElementById('forecast-status');
      if (statusDiv) statusDiv.style.display = 'none';
    }

    // =============================================================================
    // FINANCIAL ENGINE RENDER FUNCTIONS
    // =============================================================================

    function renderCashFlowCharts(data, vizId) {
      try {
        // Check if using real data or demo fallback
        const hasRealInflows = data.inflows && Object.keys(data.inflows).length > 0;
        const hasRealOutflows = data.outflows && Object.keys(data.outflows).length > 0;
        const isDemo = !hasRealInflows || !hasRealOutflows;

        // Sankey diagram for cash flow
        const inflows = hasRealInflows ? data.inflows : { 'Revenue': 500000, 'Services': 150000 };
        const outflows = hasRealOutflows ? data.outflows : { 'Salaries': 200000, 'Operations': 100000, 'Marketing': 50000 };

        // Add demo indicator banner if using fallback data
        const container = document.getElementById(`sankey-${vizId}`)?.parentElement;
        if (container && isDemo) {
          const demoBanner = document.createElement('div');
          demoBanner.className = 'demo-data-indicator';
          demoBanner.innerHTML = '<span class="demo-badge">âš ï¸ DEMO DATA</span> Using sample cash flow data for visualization preview';
          demoBanner.style.cssText = 'background: linear-gradient(90deg, #ff9800, #f57c00); color: white; padding: 8px 16px; border-radius: 6px; margin-bottom: 12px; font-weight: 600; text-align: center;';
          container.insertBefore(demoBanner, container.firstChild);
        }

        if (typeof SankeyChart !== 'undefined') {
          SankeyChart.createCashFlow(`sankey-${vizId}`, {
            inflows,
            outflows,
            totalInflows: Object.values(inflows).reduce((a, b) => a + b, 0),
            totalOutflows: Object.values(outflows).reduce((a, b) => a + b, 0)
          });
        }

        // Gauge for cash runway
        const runway = data.runway_months || data.metrics?.runway_months || 12;
        if (typeof GaugeChart !== 'undefined') {
          GaugeChart.create(`cashflow-gauge-${vizId}`, {
            value: runway,
            max: 24,
            title: 'Cash Runway',
            unit: 'months',
            thresholds: { danger: 6, warning: 12, success: 18 }
          });
        }
      } catch (e) {
        console.error('Cash flow chart error:', e);
      }
    }

    function renderBudgetVarianceCharts(data, vizId) {
      try {
        // Check if using real data or demo fallback
        const hasRealCategories = data.categories || data.departments;
        const hasRealBudgets = data.budgets || data.budget_amounts;
        const hasRealActuals = data.actuals || data.actual_amounts;
        const isDemo = !hasRealCategories || !hasRealBudgets || !hasRealActuals;

        const categories = data.categories || data.departments || ['Marketing', 'Engineering', 'Sales', 'Operations'];
        const budgets = data.budgets || data.budget_amounts || [150000, 250000, 100000, 175000];
        const actuals = data.actuals || data.actual_amounts || [125000, 280000, 95000, 180000];

        // Add demo indicator banner if using fallback data
        const container = document.getElementById(`waterfall-${vizId}`)?.parentElement;
        if (container && isDemo) {
          const demoBanner = document.createElement('div');
          demoBanner.className = 'demo-data-indicator';
          demoBanner.innerHTML = '<span class="demo-badge">âš ï¸ DEMO DATA</span> Using sample budget variance data for visualization preview';
          demoBanner.style.cssText = 'background: linear-gradient(90deg, #ff9800, #f57c00); color: white; padding: 8px 16px; border-radius: 6px; margin-bottom: 12px; font-weight: 600; text-align: center;';
          container.insertBefore(demoBanner, container.firstChild);
        }

        if (typeof WaterfallChart !== 'undefined') {
          WaterfallChart.createBudgetVariance(`waterfall-${vizId}`, budgets, actuals, categories);
        }

        if (typeof BulletChart !== 'undefined') {
          const depts = categories.map((name, i) => ({
            name,
            actual: actuals[i],
            budget: budgets[i]
          }));
          BulletChart.createBudgetComparison(`bullet-${vizId}`, depts);
        }
      } catch (e) {
        console.error('Budget variance chart error:', e);
      }
    }

    function renderProfitMarginCharts(data, vizId) {
      try {
        // Check if using real data or demo fallback
        // Backend returns: summary.average_margin, segments.product, segments.customer
        const hasRealMargin = data.summary?.average_margin !== undefined ||
          data.average_margin !== undefined ||
          data.overall_margin !== undefined;
        const hasRealSegments = data.segments?.product || data.segments?.customer;
        const isDemo = !hasRealMargin;

        const margin = data.summary?.average_margin || data.average_margin || data.overall_margin || 25;

        // Add demo indicator banner if using fallback data
        const gaugeContainer = document.getElementById(`margin-gauge-${vizId}`);
        if (gaugeContainer && isDemo) {
          showDemoIndicator(`margin-gauge-${vizId}`, 'Profit Margin');
        }

        if (typeof GaugeChart !== 'undefined' && gaugeContainer) {
          GaugeChart.create(`margin-gauge-${vizId}`, {
            value: margin,
            max: 50,
            title: isDemo ? 'Profit Margin (Demo)' : 'Profit Margin',
            unit: '%',
            thresholds: { danger: 10, warning: 20, success: 30 }
          });
        }

        // Treemap for margin breakdown - construct from segments if available
        const treemapContainer = document.getElementById(`margin-treemap-${vizId}`);
        let breakdown = null;

        if (hasRealSegments && data.segments?.product?.top_performers) {
          // Build breakdown from real segment data
          // Note: Backend returns top_performers as array of names, so we'll create estimated values
          breakdown = {};
          if (data.segments.product?.top_performers) {
            breakdown['Top Products'] = {};
            data.segments.product.top_performers.forEach((name, i) => {
              breakdown['Top Products'][name] = 100000 - (i * 15000); // Estimated for viz
            });
          }
          if (data.segments.customer?.top_performers) {
            breakdown['Top Customers'] = {};
            data.segments.customer.top_performers.forEach((name, i) => {
              breakdown['Top Customers'][name] = 80000 - (i * 12000);
            });
          }
        }

        if (!breakdown || Object.keys(breakdown).length === 0) {
          breakdown = {
            'Products': { 'Product A': 35000, 'Product B': 25000, 'Product C': 18000 },
            'Services': { 'Consulting': 15000, 'Support': 10000, 'Training': 8000 }
          };
          if (treemapContainer) {
            showDemoIndicator(`margin-treemap-${vizId}`, 'Margin Breakdown');
          }
        }

        if (typeof TreemapChart !== 'undefined' && treemapContainer) {
          TreemapChart.createCostComposition(`margin-treemap-${vizId}`, breakdown, {
            title: 'Margin by Segment'
          });
        }
      } catch (e) {
        console.error('Profit margin chart error:', e);
        showChartError(`margin-gauge-${vizId}`, 'Profit Margin', e.message);
      }
    }

    function renderRevenueForecastChart(data, vizId) {
      try {
        const isDemo = !data.historical && !data.forecast && !data.predictions;
        const historical = data.historical || {
          x: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'],
          y: [180000, 195000, 210000, 225000, 240000, 260000]
        };

        const forecast = data.forecast || data.predictions || {
          x: ['Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
          y: [280000, 300000, 320000, 345000, 370000, 400000],
          upper: [310000, 340000, 370000, 405000, 440000, 480000],
          lower: [250000, 260000, 270000, 285000, 300000, 320000]
        };

        if (isDemo) {
          showDemoIndicator(`forecast-${vizId}`, 'Revenue Forecast');
        }

        if (typeof ForecastAreaChart !== 'undefined') {
          ForecastAreaChart.create(`forecast-${vizId}`, {
            historical,
            forecast,
            forecastStart: forecast.x?.[0] || 'Jul',
            title: isDemo ? 'Revenue Forecast (Demo Data)' : 'Revenue Forecast'
          });
        }
      } catch (e) {
        console.error('Revenue forecast chart error:', e);
        showChartError(`forecast-${vizId}`, 'Revenue Forecast', e.message);
      }
    }

    function renderCustomerLTVCharts(data, vizId) {
      try {
        // Check for real segment data - backend returns segments.stats array
        const hasRealSegments = data.segments?.stats || data.customer_segments;
        const isDemo = !hasRealSegments;

        // Transform backend format to chart format if needed
        let segments;
        if (data.segments?.stats && Array.isArray(data.segments.stats)) {
          segments = data.segments.stats.map(s => ({
            name: s.segment || s.name || 'Segment',
            recency: s.recency_score || s.recency || 50,
            frequency: s.frequency_score || s.frequency || 50,
            monetary: s.monetary_score || s.monetary || 50
          }));
        } else {
          segments = data.customer_segments || [
            { name: 'VIP', recency: 90, frequency: 85, monetary: 95 },
            { name: 'At-Risk', recency: 30, frequency: 60, monetary: 70 },
            { name: 'New', recency: 95, frequency: 25, monetary: 40 }
          ];
        }

        if (isDemo) {
          showDemoIndicator(`ltv-radar-${vizId}`, 'Customer Segments');
        }

        if (typeof RadarChart !== 'undefined') {
          RadarChart.createRFM(`ltv-radar-${vizId}`, segments);
        }

        // Add KPI cards if summary data exists
        const kpiContainer = document.getElementById(`ltv-kpi-${vizId}`);
        if (kpiContainer && data.summary) {
          kpiContainer.innerHTML = `
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; padding: 1rem;">
              <div class="fin-kpi fin-kpi-success">
                <div class="fin-kpi-label">Avg Customer LTV</div>
                <div class="fin-kpi-value">$${(data.summary.avg_clv || 0).toLocaleString()}</div>
              </div>
              <div class="fin-kpi fin-kpi-warning">
                <div class="fin-kpi-label">Churn Rate</div>
                <div class="fin-kpi-value">${((data.summary.churn_rate || 0) * 100).toFixed(1)}%</div>
              </div>
            </div>
          `;
        } else if (kpiContainer) {
          kpiContainer.innerHTML = `
            <div class="demo-data-notice" style="padding: 2rem; text-align: center; color: #94a3b8;">
              <div style="font-size: 2rem; margin-bottom: 0.5rem;">ğŸ“Š</div>
              <div>LTV metrics require customer transaction history</div>
            </div>
          `;
        }
      } catch (e) {
        console.error('Customer LTV chart error:', e);
        showChartError(`ltv-radar-${vizId}`, 'Customer LTV', e.message);
      }
    }

    function renderCostOptimizationCharts(data, vizId) {
      try {
        console.log('Cost Optimization data:', JSON.stringify(data, null, 2).substring(0, 500));

        const treemapContainer = document.getElementById(`cost-treemap-${vizId}`);
        if (!treemapContainer) {
          console.error('Cost treemap container not found:', `cost-treemap-${vizId}`);
          return;
        }

        const hasRealData = data.cost_categories && Object.keys(data.cost_categories).length > 0;
        const isDemo = !hasRealData;

        console.log('Cost Optimization - hasRealData:', hasRealData, 'cost_categories:', data.cost_categories);

        // For flat category data, wrap it for the treemap
        let categories = null;
        if (hasRealData) {
          // Backend returns flat {category: value} - convert to nested for better treemap
          const flat = data.cost_categories;
          // Check if values are numbers (flat) or objects (already nested)
          const firstVal = Object.values(flat)[0];
          console.log('First value type:', typeof firstVal, firstVal);
          if (typeof firstVal === 'number') {
            categories = { 'Cost Categories': flat };
          } else {
            categories = flat;
          }
        } else {
          categories = data.breakdown || {
            'Salaries': { 'Engineering': 180000, 'Sales': 85000, 'Marketing': 65000 },
            'Operations': { 'Infrastructure': 45000, 'Office': 35000, 'Utilities': 15000 },
            'Technology': { 'Cloud': 55000, 'Software': 25000, 'Hardware': 20000 }
          };
        }

        console.log('Final categories for treemap:', JSON.stringify(categories).substring(0, 200));

        const costTreemapContainer = document.getElementById(`cost-treemap-${vizId}`);
        console.log('Treemap container found:', !!costTreemapContainer, `cost-treemap-${vizId}`);

        if (isDemo) {
          showDemoIndicator(`cost-treemap-${vizId}`, 'Cost Breakdown');
        }

        if (typeof TreemapChart !== 'undefined') {
          console.log('Calling TreemapChart.createCostComposition...');
          const result = TreemapChart.createCostComposition(`cost-treemap-${vizId}`, categories);
          console.log('TreemapChart result:', result);
        } else {
          console.error('TreemapChart not defined');
        }

        // Show Pareto chart if available
        const paretoContainer = document.getElementById(`cost-pareto-${vizId}`);
        if (paretoContainer && data.pareto?.graph) {
          paretoContainer.innerHTML = '<div style="color: #10b981; padding: 1rem;">âœ“ Pareto analysis in Full Results</div>';
        } else if (paretoContainer && isDemo) {
          paretoContainer.innerHTML = `
            <div class="demo-data-notice" style="padding: 2rem; text-align: center; color: #94a3b8;">
              <div style="font-size: 2rem; margin-bottom: 0.5rem;">ğŸ“ˆ</div>
              <div>Pareto analysis requires category grouping</div>
            </div>
          `;
        }
      } catch (e) {
        console.error('Cost optimization chart error:', e);
        showChartError(`cost-treemap-${vizId}`, 'Cost Optimization', e.message);
      }
    }

    function renderROIPredictionCharts(data, vizId) {
      try {
        // Check for real sensitivity data - backend returns low_case_npv/high_case_npv
        const hasRealSensitivity = data.sensitivity?.low_case_npv || data.sensitivity?.low_impact;
        const isDemo = !hasRealSensitivity;

        const sensitivity = data.sensitivity || {
          factors: ['Price', 'Volume', 'COGS', 'Marketing'],
          low_case_npv: [-85000, -120000, -45000, -30000],
          high_case_npv: [95000, 150000, 35000, 60000]
        };

        if (isDemo) {
          showDemoIndicator(`roi-tornado-${vizId}`, 'ROI Sensitivity');
        }

        if (typeof TornadoChart !== 'undefined') {
          TornadoChart.create(`roi-tornado-${vizId}`, {
            factors: sensitivity.factors || ['Price', 'Volume', 'COGS', 'Marketing'],
            lowImpact: sensitivity.low_case_npv || sensitivity.low_impact || [-85000, -120000, -45000, -30000],
            highImpact: sensitivity.high_case_npv || sensitivity.high_impact || [95000, 150000, 35000, 60000],
            title: isDemo ? 'ROI Sensitivity (Demo)' : 'ROI Sensitivity'
          });
        }

        // Extract ROI from correct path
        const roi = data.basic_roi?.average_roi || data.predicted_roi || data.roi || 25;
        const isRoiDemo = !data.basic_roi?.average_roi && !data.predicted_roi;

        if (isRoiDemo) {
          showDemoIndicator(`roi-gauge-${vizId}`, 'Predicted ROI');
        }

        if (typeof GaugeChart !== 'undefined') {
          GaugeChart.create(`roi-gauge-${vizId}`, {
            value: roi,
            max: 100,
            title: isRoiDemo ? 'Predicted ROI (Demo)' : 'Predicted ROI',
            unit: '%',
            thresholds: { danger: 10, warning: 25, success: 40 }
          });
        }
      } catch (e) {
        console.error('ROI prediction chart error:', e);
        showChartError(`roi-tornado-${vizId}`, 'ROI Prediction', e.message);
      }
    }

    function renderMarketBasketChart(data, vizId) {
      try {
        const container = document.getElementById(`basket-network-${vizId}`);
        if (!container) {
          console.error('Market basket container not found');
          return;
        }

        const rules = data.rules || data.association_rules || [];
        const isDemo = rules.length === 0 || (!data.rules && !data.association_rules);

        if (rules.length === 0) {
          container.innerHTML = `
            <div class="demo-data-notice" style="padding: 3rem; text-align: center; color: #94a3b8;">
              <div style="font-size: 3rem; margin-bottom: 1rem;">ğŸ›’</div>
              <div style="font-size: 1.1rem; margin-bottom: 0.5rem;">No Product Associations Found</div>
              <div style="font-size: 0.85rem;">Market basket analysis requires transaction-level data with multiple products per order.</div>
            </div>
          `;
          return;
        }

        if (isDemo) {
          showDemoIndicator(`basket-network-${vizId}`, 'Product Associations');
        }

        if (typeof NetworkGraph !== 'undefined') {
          NetworkGraph.createMarketBasket(`basket-network-${vizId}`, rules);
        } else {
          console.error('NetworkGraph not loaded');
          container.innerHTML = '<div style="color: #ef4444; padding: 2rem;">Chart library not loaded</div>';
        }
      } catch (e) {
        console.error('Market basket chart error:', e);
        showChartError(`basket-network-${vizId}`, 'Market Basket', e.message);
      }
    }

    function renderPricingStrategyChart(data, vizId) {
      try {
        const container = document.getElementById(`pricing-surface-${vizId}`);
        if (!container) return;

        // Handle elasticity as array (backend returns array of objects)
        let elasticity, basePrice, maxQuantity;
        const isDemo = !data.elasticity || (Array.isArray(data.elasticity) && data.elasticity.length === 0);

        if (Array.isArray(data.elasticity) && data.elasticity.length > 0) {
          const primary = data.elasticity[0];
          elasticity = primary.elasticity || -1.5;
          basePrice = primary.avg_price || data.optimal_price || 100;
          maxQuantity = primary.avg_quantity || data.max_quantity || 1000;
        } else if (typeof data.elasticity === 'number') {
          elasticity = data.elasticity;
          basePrice = data.optimal_price || data.base_price || 100;
          maxQuantity = data.max_quantity || 1000;
        } else {
          elasticity = -1.5;
          basePrice = 100;
          maxQuantity = 1000;
        }

        if (isDemo) {
          showDemoIndicator(`pricing-surface-${vizId}`, 'Price Optimization');
        }

        if (typeof SurfaceChart !== 'undefined') {
          SurfaceChart.createFromElasticity(`pricing-surface-${vizId}`, basePrice, maxQuantity, elasticity);
        }
      } catch (e) {
        console.error('Pricing strategy chart error:', e);
        showChartError(`pricing-surface-${vizId}`, 'Pricing Strategy', e.message);
      }
    }

    function renderSpendPatternCharts(data, vizId) {
      try {
        const container = document.getElementById(`spend-sankey-${vizId}`);
        if (!container) return;

        const hasRealData = data.category_totals && Object.keys(data.category_totals).length > 0;
        const isDemo = !hasRealData;

        const categories = hasRealData ? data.category_totals : (data.spend_by_category || {
          'Marketing': 85000, 'Salaries': 320000, 'Infrastructure': 65000
        });

        if (isDemo) {
          showDemoIndicator(`spend-sankey-${vizId}`, 'Spend Allocation');
        }

        if (typeof SankeyChart !== 'undefined' && Object.keys(categories).length > 0) {
          // Wrap in expected structure
          SankeyChart.createSpendAllocation(`spend-sankey-${vizId}`, { categories });
        } else if (Object.keys(categories).length === 0) {
          container.innerHTML = `
            <div class="demo-data-notice" style="padding: 2rem; text-align: center; color: #94a3b8;">
              <div style="font-size: 2rem; margin-bottom: 0.5rem;">ğŸ’³</div>
              <div>No spend categories detected</div>
            </div>
          `;
        }

        // Trend chart placeholder
        const trendContainer = document.getElementById(`spend-trend-${vizId}`);
        if (trendContainer) {
          if (data.patterns?.temporal?.graph) {
            trendContainer.innerHTML = '<div style="color: #10b981; padding: 1rem;">âœ“ Temporal analysis in Full Results</div>';
          } else {
            trendContainer.innerHTML = `
              <div class="demo-data-notice" style="padding: 2rem; text-align: center; color: #94a3b8;">
                <div style="font-size: 2rem; margin-bottom: 0.5rem;">ğŸ“…</div>
                <div>Trend analysis requires date column</div>
              </div>
            `;
          }
        }
      } catch (e) {
        console.error('Spend pattern chart error:', e);
        showChartError(`spend-sankey-${vizId}`, 'Spend Patterns', e.message);
      }
    }

    function renderInventoryChart(data, vizId) {
      try {
        console.log('Inventory data:', JSON.stringify(data, null, 2).substring(0, 500));

        const container = document.getElementById(`inventory-treemap-${vizId}`);
        if (!container) {
          console.error('Inventory treemap container not found:', `inventory-treemap-${vizId}`);
          return;
        }

        const hasRealData = data.abc_analysis &&
          (Object.keys(data.abc_analysis.classA || {}).length > 0 ||
            Object.keys(data.abc_analysis.classB || {}).length > 0 ||
            Object.keys(data.abc_analysis.classC || {}).length > 0);
        const isDemo = !hasRealData;

        const abcAnalysis = hasRealData ? data.abc_analysis : {
          classA: { 'SKU-001': 150000, 'SKU-002': 120000, 'SKU-003': 95000 },
          classB: { 'SKU-004': 45000, 'SKU-005': 35000, 'SKU-006': 28000 },
          classC: { 'SKU-007': 8000, 'SKU-008': 5000, 'SKU-009': 3000 }
        };

        console.log('ABC Analysis for treemap:', abcAnalysis);

        if (isDemo) {
          showDemoIndicator(`inventory-treemap-${vizId}`, 'Inventory ABC');
        }

        if (typeof TreemapChart !== 'undefined') {
          TreemapChart.createInventoryABC(`inventory-treemap-${vizId}`, abcAnalysis);
        } else {
          console.error('TreemapChart not defined');
        }
      } catch (e) {
        console.error('Inventory chart error:', e);
        showChartError(`inventory-treemap-${vizId}`, 'Inventory', e.message);
      }
    }

    function renderResourceUtilizationChart(data, vizId) {
      try {
        const hasRealData = data.overall_utilization !== undefined || data.utilization_rate !== undefined;
        const isDemo = !hasRealData;
        const utilization = data.overall_utilization || data.utilization_rate || 72;

        if (isDemo) {
          showDemoIndicator(`resource-gauge-${vizId}`, 'Utilization');
        }

        if (typeof GaugeChart !== 'undefined') {
          GaugeChart.create(`resource-gauge-${vizId}`, {
            value: utilization,
            max: 100,
            title: isDemo ? 'Resource Utilization (Demo)' : 'Resource Utilization',
            unit: '%',
            thresholds: { danger: 30, warning: 60, success: 80 }
          });
        }
      } catch (e) {
        console.error('Resource utilization chart error:', e);
        showChartError(`resource-gauge-${vizId}`, 'Resource Utilization', e.message);
      }
    }

    // Helper: Show demo data indicator
    function showDemoIndicator(containerId, chartName) {
      const container = document.getElementById(containerId);
      if (!container) return;

      // Add a small badge
      const badge = document.createElement('div');
      badge.className = 'demo-data-badge';
      badge.innerHTML = 'ğŸ“‹ Demo Data';
      badge.style.cssText = `
        position: absolute;
        top: 8px;
        right: 8px;
        background: rgba(245, 158, 11, 0.2);
        color: #fbbf24;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.7rem;
        font-weight: 600;
        z-index: 10;
        border: 1px solid rgba(245, 158, 11, 0.3);
      `;

      // Ensure container is positioned
      if (getComputedStyle(container).position === 'static') {
        container.style.position = 'relative';
      }
      container.appendChild(badge);
    }

    // Helper: Show chart error
    function showChartError(containerId, chartName, errorMsg) {
      const container = document.getElementById(containerId);
      if (!container) return;

      container.innerHTML = `
        <div style="padding: 2rem; text-align: center; color: #f87171;">
          <div style="font-size: 2rem; margin-bottom: 0.5rem;">âš ï¸</div>
          <div style="font-weight: 500;">${chartName} Error</div>
          <div style="font-size: 0.8rem; color: #94a3b8; margin-top: 0.5rem;">${errorMsg || 'Chart failed to render'}</div>
        </div>
      `;
    }

    // Enterprise dropdown hover handler
    document.querySelectorAll('.nav-dropdown').forEach(dropdown => {
      dropdown.addEventListener('mouseenter', () => {
        dropdown.querySelector('.nav-dropdown-menu').style.display = 'block';
      });
      dropdown.addEventListener('mouseleave', () => {
        dropdown.querySelector('.nav-dropdown-menu').style.display = 'none';
      });
    });

    log('Ready', 'info');
  </script>
</body>

</html>