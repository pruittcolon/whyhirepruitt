"""
JWT Authentication Manager
services/api-gateway/src/auth/auth_manager.py

Security features:
- JWT token generation/validation
- Refresh token rotation
- Redis-backed replay protection
- Role-based access control
"""

import jwt
from datetime import datetime, timedelta
from typing import Dict, Optional
import redis.asyncio as redis
import hashlib

class JWTAuthManager:
    """Production JWT authentication with replay protection."""
    
    def __init__(self, secret_key: str, redis_url: str):
        self.secret = secret_key
        self.algorithm = "HS256"
        self.access_expiry = timedelta(minutes=15)
        self.refresh_expiry = timedelta(days=7)
        self.redis = redis.from_url(redis_url)
    
    async def create_tokens(self, user_id: str, roles: list) -> Dict[str, str]:
        """Generate access and refresh token pair."""
        now = datetime.utcnow()
        
        # Access token (short-lived)
        access_payload = {
            "sub": user_id,
            "roles": roles,
            "type": "access",
            "iat": now,
            "exp": now + self.access_expiry,
            "jti": self._generate_jti()
        }
        access_token = jwt.encode(access_payload, self.secret, self.algorithm)
        
        # Refresh token (long-lived)
        refresh_payload = {
            "sub": user_id,
            "type": "refresh",
            "iat": now,
            "exp": now + self.refresh_expiry,
            "jti": self._generate_jti()
        }
        refresh_token = jwt.encode(refresh_payload, self.secret, self.algorithm)
        
        return {"access_token": access_token, "refresh_token": refresh_token}
    
    async def validate_token(self, token: str) -> Optional[Dict]:
        """Validate token with replay protection."""
        try:
            payload = jwt.decode(token, self.secret, algorithms=[self.algorithm])
            
            # Check if token has been revoked
            if await self._is_revoked(payload["jti"]):
                return None
                
            return payload
            
        except jwt.ExpiredSignatureError:
            return None
        except jwt.InvalidTokenError:
            return None
    
    async def revoke_token(self, token: str):
        """Add token to revocation list."""
        payload = jwt.decode(token, self.secret, algorithms=[self.algorithm])
        ttl = payload["exp"] - datetime.utcnow().timestamp()
        await self.redis.setex(f"revoked:{payload['jti']}", int(ttl), "1")
    
    async def _is_revoked(self, jti: str) -> bool:
        """Check if token is in revocation list."""
        return await self.redis.exists(f"revoked:{jti}")
    
    def _generate_jti(self) -> str:
        """Generate unique token identifier."""
        import uuid
        return str(uuid.uuid4())
